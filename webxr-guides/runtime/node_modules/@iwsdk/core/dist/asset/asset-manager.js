import '../runtime/three.js';
import { CacheManager } from './cache-manager.js';
import { AudioAssetLoader } from './loaders/audio-loader.js';
import { GLTFAssetLoader } from './loaders/gltf-loader.js';
import { HDRTextureAssetLoader } from './loaders/hdr-texture-loader.js';
import { TextureAssetLoader } from './loaders/texture-loader.js';
import { LoadingManager } from 'three';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Asset types supported by the {@link AssetManager}.
 * @category Assets
 */
var AssetType;
(function (AssetType) {
    AssetType["GLTF"] = "gltf";
    AssetType["Audio"] = "audio";
    AssetType["Texture"] = "texture";
    AssetType["HDRTexture"] = "hdr-texture";
})(AssetType || (AssetType = {}));
/**
 * Centralized asset loader with caching and priorityâ€‘based preloading.
 *
 * @remarks
 * - Initializes loader instances against a shared `LoadingManager`.
 * - `preloadAssets` loads critical assets first (blocking), then starts background ones.
 * - Use `getGLTF`/`getTexture`/`getAudio` to retrieve cached results by key.
 * @category Assets
 */
class AssetManager {
    /**
     * Initialize loaders and bind to the current world/renderer.
     */
    static init(renderer, world, options = {}) {
        this.world = world;
        this.loadingManager = new LoadingManager();
        // Initialize all specialized loaders
        AudioAssetLoader.init(this.loadingManager);
        GLTFAssetLoader.init(this.loadingManager, renderer, options);
        TextureAssetLoader.init(this.loadingManager);
        HDRTextureAssetLoader.init(this.loadingManager);
    }
    /** Preload assets with critical/background prioritization. */
    static async preloadAssets(manifest) {
        // Separate by priority
        const criticalAssets = Object.entries(manifest).filter(([_, config]) => {
            return config.priority !== 'background';
        });
        const backgroundAssets = Object.entries(manifest).filter(([_, config]) => {
            return config.priority === 'background';
        });
        // Phase 1: Load critical assets (blocking)
        const criticalPromises = criticalAssets.map(([key, config]) => {
            CacheManager.setKeyToUrl(key, config.url);
            return this.loadAssetByType(config.url, config.type, key);
        });
        await Promise.all(criticalPromises);
        // Phase 2: Start background loading (non-blocking)
        backgroundAssets.forEach(([key, config]) => {
            CacheManager.setKeyToUrl(key, config.url);
            this.loadAssetByType(config.url, config.type, key).catch((err) => console.warn(`Background asset failed: ${key}`, err));
        });
    }
    static async loadAssetByType(url, type, key) {
        switch (type) {
            case AssetType.GLTF:
                return GLTFAssetLoader.loadGLTF(url, key);
            case AssetType.Audio:
                return AudioAssetLoader.loadAudio(url);
            case AssetType.Texture:
                return TextureAssetLoader.loadTexture(url);
            case AssetType.HDRTexture:
                return HDRTextureAssetLoader.loadHDRTexture(url);
            default:
                throw new Error(`Unsupported asset type: ${type}`);
        }
    }
    /** Load a GLTF by URL; optionally register a logical key. */
    static loadGLTF(url, key) {
        return GLTFAssetLoader.loadGLTF(url, key);
    }
    // GLXF has been removed from the asset pipeline. Use World.loadLevel(url).
    /** Fetch any cached asset by logical key. */
    static getAsset(key) {
        return CacheManager.getAssetByKey(key);
    }
    // Public API Methods - delegate to specialized loaders
    /** Load an AudioBuffer by URL; optionally register a logical key. */
    static async loadAudio(url, key) {
        if (key) {
            CacheManager.setKeyToUrl(key, url);
        }
        else {
            CacheManager.setKeyToUrl(url, url);
        }
        return AudioAssetLoader.loadAudio(url);
    }
    /** Get a cached AudioBuffer by logical key. */
    static getAudio(key) {
        return AudioAssetLoader.getAudio(key);
    }
    /** Load a Texture by URL; optionally register a logical key. */
    static async loadTexture(url, key) {
        if (key) {
            CacheManager.setKeyToUrl(key, url);
        }
        else {
            CacheManager.setKeyToUrl(url, url);
        }
        return TextureAssetLoader.loadTexture(url);
    }
    /** Get a cached Texture by logical key. */
    static getTexture(key) {
        return TextureAssetLoader.getTexture(key);
    }
    /** Load an HDR equirectangular texture; optionally register a logical key. */
    static async loadHDRTexture(url, key) {
        if (key) {
            CacheManager.setKeyToUrl(key, url);
        }
        else {
            CacheManager.setKeyToUrl(url, url);
        }
        return HDRTextureAssetLoader.loadHDRTexture(url);
    }
    /** Get a cached GLTF by logical key. */
    static getGLTF(key) {
        return GLTFAssetLoader.getGLTF(key);
    }
}

export { AssetManager, AssetType };
//# sourceMappingURL=asset-manager.js.map
