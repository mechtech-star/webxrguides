import { AudioSource } from './audio.js';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** Utility helpers to control {@link AudioSource} without touching Three audio.
 * @category Audio
 */
class AudioUtils {
    /**
     * Play audio on an entity
     * @param entity - Entity with Audio component
     * @param fadeIn - Fade in duration in seconds
     */
    static play(entity, fadeIn = 0) {
        const index = entity.index;
        // Check if entity has audio by checking if data exists
        if (AudioSource.data.src[index] === undefined) {
            console.warn('Entity does not have Audio component');
            return;
        }
        AudioSource.data._playRequested[index] = 1;
        AudioSource.data._fadeIn[index] = fadeIn;
    }
    /**
     * Pause audio on an entity
     * @param entity - Entity with Audio component
     * @param fadeOut - Fade out duration in seconds
     */
    static pause(entity, fadeOut = 0) {
        const index = entity.index;
        if (AudioSource.data.src[index] === undefined) {
            console.warn('Entity does not have Audio component');
            return;
        }
        AudioSource.data._pauseRequested[index] = 1;
        AudioSource.data._fadeOut[index] = fadeOut;
    }
    /**
     * Stop audio on an entity
     * @param entity - Entity with Audio component
     */
    static stop(entity) {
        const index = entity.index;
        if (AudioSource.data.src[index] === undefined) {
            console.warn('Entity does not have Audio component');
            return;
        }
        AudioSource.data._stopRequested[index] = 1;
    }
    /**
     * Check if audio is playing on an entity
     * @param entity - Entity with Audio component
     * @returns True if audio is playing
     */
    static isPlaying(entity) {
        const index = entity.index;
        if (AudioSource.data.src[index] === undefined) {
            return false;
        }
        return AudioSource.data._isPlaying[index] === 1;
    }
    /**
     * Set volume on an entity's audio
     * @param entity - Entity with Audio component
     * @param volume - Volume level (0.0 to 1.0)
     */
    static setVolume(entity, volume) {
        const index = entity.index;
        if (AudioSource.data.src[index] === undefined) {
            console.warn('Entity does not have Audio component');
            return;
        }
        AudioSource.data.volume[index] = Math.max(0, Math.min(1, volume));
    }
    /**
     * Get volume from an entity's audio
     * @param entity - Entity with Audio component
     * @returns Current volume level
     */
    static getVolume(entity) {
        const index = entity.index;
        if (AudioSource.data.src[index] === undefined) {
            return 0;
        }
        return AudioSource.data.volume[index];
    }
    /**
     * Preload audio for an entity
     * @param entity - Entity with Audio component
     * @returns Promise that resolves when audio is loaded
     */
    static async preload(entity) {
        const index = entity.index;
        if (AudioSource.data.src[index] === undefined) {
            throw new Error('Entity does not have Audio component');
        }
        // Wait for loading to complete
        return new Promise((resolve) => {
            const checkLoaded = () => {
                if (AudioSource.data._loaded[index]) {
                    resolve();
                }
                else if (!AudioSource.data._loading[index] &&
                    !AudioSource.data._loaded[index]) {
                    // Not loading and not loaded, might need to wait for system update
                    setTimeout(checkLoaded, 16);
                }
                else {
                    // Currently loading
                    setTimeout(checkLoaded, 16);
                }
            };
            checkLoaded();
        });
    }
    /**
     * Create a one-shot audio entity that auto-removes after playing
     * @param world - World instance
     * @param src - Audio source path
     * @param options - Additional audio options
     * @returns Created entity
     */
    static createOneShot(world, src, options = {}) {
        var _a, _b;
        const entity = world.createEntity();
        entity.addComponent(AudioSource, {
            src,
            volume: (_a = options.volume) !== null && _a !== void 0 ? _a : 1.0,
            positional: (_b = options.positional) !== null && _b !== void 0 ? _b : false,
            autoplay: true,
            loop: false,
        });
        if (options.positional && options.position) ;
        // Auto-remove entity when sound ends
        // This would be handled by the AudioSystem when detecting ended non-looping sounds
        return entity;
    }
}

export { AudioUtils };
//# sourceMappingURL=audio-utils.js.map
