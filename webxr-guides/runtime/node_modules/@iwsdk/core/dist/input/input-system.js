import { createSystem } from '../ecs/system.js';
import { VisibilityState } from '../ecs/world.js';
import 'elics';
import '../ecs/component-registry.js';
import { Transform } from '../transform/transform.js';
import '../runtime/three.js';
import { Interactable, Hovered, Pressed } from './state-tags.js';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Samples XR poses (hands/controllers/head) and gamepads, curates the set of
 * interactables for pointer raycasting, and attaches minimal event listeners.
 *
 * @remarks
 * - Scheduled after player movement so pointers reflect updated transforms.
 * - Rebuilds the interactable list every frame when in XR mode.
 * - Adds transient `Hovered` / `Pressed` tags so other systems can react declaratively.
 *
 * @category Input
 * @example React to Hovered / Pressed
 * ```ts
 * export class HighlightSystem extends createSystem({
 *   items: { required: [Interactable] }
 * }) {
 *   update() {
 *     this.queries.items.entities.forEach(e => {
 *       e.object3D.visible = !e.hasComponent(Pressed);
 *     })
 *   }
 * }
 * ```
 */
class InputSystem extends createSystem({
    interactable: { required: [Interactable, Transform] },
}, {}) {
    constructor() {
        super(...arguments);
        this.intersectables = [];
        this.shouldSetIntersectables = false;
        this.listeners = new WeakMap();
        this.lastBVHUpdate = new WeakMap();
    }
    init() {
        // Track XR visibility for scoped intersections (XR mode only)
        this.cleanupFuncs.push(this.visibilityState.subscribe((value) => {
            this.shouldSetIntersectables = value === VisibilityState.Visible;
        }));
        // Setup/cleanup event listeners when entities qualify/disqualify
        this.queries.interactable.subscribe('qualify', (entity) => {
            this.setupEventListeners(entity);
        });
        this.queries.interactable.subscribe('disqualify', (entity) => {
            this.cleanupEventListeners(entity);
        });
    }
    update(delta, time) {
        // Update input sampling first
        this.input.update(this.xrManager, delta, time);
        // Rebuild interactables list every frame in XR mode
        if (this.shouldSetIntersectables) {
            this.intersectables.length = 0;
            for (const entity of this.queries.interactable.entities) {
                if (entity.object3D) {
                    this.intersectables.push(entity.object3D);
                }
            }
            this.scene.interactableDescendants = this.intersectables;
        }
        else {
            // In 2D mode, clear the reference so pointer-events uses default behavior
            this.scene.interactableDescendants = undefined;
        }
    }
    setupEventListeners(entity) {
        const object3D = entity.object3D;
        if (!object3D) {
            return;
        }
        // Compute BVH for all meshes in the entity hierarchy for fast raycasting
        this.computeBoundsTreeForEntity(object3D);
        // Enable pointer events for raycasting
        object3D.pointerEvents = 'auto';
        // Throttled subtree BVH refresh helper
        const maybeRefreshBVH = () => {
            var _a;
            const now = typeof performance !== 'undefined' && performance.now
                ? performance.now()
                : Date.now();
            const last = (_a = this.lastBVHUpdate.get(object3D)) !== null && _a !== void 0 ? _a : 0;
            if (now - last > 250) {
                this.computeBoundsTreeForEntity(object3D);
                this.lastBVHUpdate.set(object3D, now);
            }
        };
        const enter = () => {
            maybeRefreshBVH();
            if (!entity.hasComponent(Hovered)) {
                entity.addComponent(Hovered);
            }
        };
        const leave = () => {
            entity.removeComponent(Hovered);
        };
        const down = () => {
            maybeRefreshBVH();
            if (!entity.hasComponent(Pressed)) {
                entity.addComponent(Pressed);
            }
        };
        const up = () => {
            entity.removeComponent(Pressed);
        };
        this.listeners.set(object3D, { enter, leave, down, up });
        object3D.addEventListener('pointerenter', enter);
        object3D.addEventListener('pointerleave', leave);
        object3D.addEventListener('pointerdown', down);
        object3D.addEventListener('pointerup', up);
    }
    computeBoundsTreeForEntity(object3D) {
        object3D.traverse((child) => {
            if (child.isMesh) {
                const mesh = child;
                if (mesh.geometry && !mesh.geometry.boundsTree) {
                    try {
                        mesh.geometry.computeBoundsTree();
                    }
                    catch (error) {
                        console.warn(`[InputSystem] Failed to compute BVH for ${mesh.name || 'unnamed'}:`, error);
                    }
                }
            }
        });
    }
    cleanupEventListeners(entity) {
        const object3D = entity.object3D;
        if (!object3D) {
            return;
        }
        const fns = this.listeners.get(object3D);
        if (fns) {
            object3D.removeEventListener('pointerenter', fns.enter);
            object3D.removeEventListener('pointerleave', fns.leave);
            object3D.removeEventListener('pointerdown', fns.down);
            object3D.removeEventListener('pointerup', fns.up);
            this.listeners.delete(object3D);
        }
        // Remove hover/press state components if they exist
        // Check hasComponent first to avoid warnings when entity is being destroyed
        // (entity destruction removes all components, so trying to remove them again causes warnings)
        if (entity.hasComponent(Hovered)) {
            entity.removeComponent(Hovered);
        }
        if (entity.hasComponent(Pressed)) {
            entity.removeComponent(Pressed);
        }
    }
}

export { InputSystem };
//# sourceMappingURL=input-system.js.map
