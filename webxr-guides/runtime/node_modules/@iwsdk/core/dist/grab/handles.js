import { HandleStore } from '@pmndrs/handle';
import '@preact/signals-core';
import '../ecs/world.js';
import { createComponent, Types } from 'elics';
import '../ecs/component-registry.js';
import '../runtime/three.js';
import { Vector3, Quaternion } from 'three';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const Handle = createComponent('Handle', {
    instance: { type: Types.Object, default: undefined },
}, 'Internal component storing an active interaction handle instance');
/** MovementMode for {@link DistanceGrabbable}. @category Grab */
const MovementMode = {
    /** Object smoothly moves with the ray cast end point of the grabbing controller. */
    MoveFromTarget: 'MoveFromTarget',
    /** Object smoothly moves toward the input source that's grabbing. */
    MoveTowardsTarget: 'MoveTowardsTarget',
    /** Object moves relative to controller delta movement while maintaining distance. */
    MoveAtSource: 'MoveAtSource',
    /** Object rotates in place without translation or scaling. */
    RotateAtSource: 'RotateAtSource',
};
class DistanceGrabHandle extends HandleStore {
    constructor(target_, getOptions = () => ({}), movementMode, returnToOrigin, moveSpeed = 0.1) {
        super(target_, getOptions);
        this.target_ = target_;
        this.getOptions = getOptions;
        this.movementMode = movementMode;
        this.returnToOrigin = returnToOrigin;
        this.moveSpeed = moveSpeed;
    }
    update(time) {
        var _a;
        if (this.movementMode === MovementMode.RotateAtSource ||
            this.movementMode === MovementMode.MoveFromTarget) {
            super.update(time);
            return;
        }
        const target = this.getTarget();
        if (target == null ||
            this.inputState.size === 0 ||
            (this.latestMoveEvent == null &&
                ((_a = this.getOptions().alwaysUpdate) !== null && _a !== void 0 ? _a : false) === false)) {
            if (this.previousPointerOrigin != undefined) {
                this.previousPointerOrigin = undefined;
            }
            return;
        }
        const pointerAmount = this.inputState.size;
        target.getWorldPosition(DistanceGrabHandle._posHelper);
        target.getWorldQuaternion(DistanceGrabHandle._quatHelper);
        const position = target.position;
        const quaternion = target.quaternion;
        const rotation = target.rotation;
        const scale = target.scale;
        switch (this.movementMode) {
            case MovementMode.MoveAtSource: {
                const [p1] = this.inputState.values();
                const current = p1.pointerWorldOrigin;
                if (this.previousPointerOrigin != undefined) {
                    const delta = DistanceGrabHandle._tmp
                        .copy(current)
                        .sub(this.previousPointerOrigin);
                    DistanceGrabHandle._posHelper.add(delta);
                }
                else {
                    this.previousPointerOrigin = new Vector3().copy(current);
                }
                // Update stored previous for next frame
                this.previousPointerOrigin.copy(current);
                break;
            }
            case MovementMode.MoveTowardsTarget: {
                const [p1] = this.inputState.values();
                const pointerOrigin = p1.pointerWorldOrigin;
                const distance = pointerOrigin.distanceTo(DistanceGrabHandle._posHelper);
                if (distance > this.moveSpeed) {
                    const step = DistanceGrabHandle._tmp
                        .copy(pointerOrigin)
                        .sub(DistanceGrabHandle._posHelper)
                        .normalize()
                        .multiplyScalar(this.moveSpeed);
                    DistanceGrabHandle._posHelper.add(step);
                }
                else {
                    DistanceGrabHandle._posHelper.set(pointerOrigin.x, pointerOrigin.y, pointerOrigin.z);
                    DistanceGrabHandle._quatHelper.set(p1.pointerWorldQuaternion.x, p1.pointerWorldQuaternion.y, p1.pointerWorldQuaternion.z, p1.pointerWorldQuaternion.w);
                }
                break;
            }
        }
        // Convert world space transforms to local space
        if (target.parent) {
            // Get parent's inverse world matrix
            const parentWorldMatrixInverse = target.parent.matrixWorld
                .clone()
                .invert();
            // Transform desired world position to local space
            position
                .copy(DistanceGrabHandle._posHelper)
                .applyMatrix4(parentWorldMatrixInverse);
            // Transform desired world quaternion to local space
            const parentWorldQuaternionInverse = target.parent
                .getWorldQuaternion(new Quaternion())
                .invert();
            quaternion
                .copy(DistanceGrabHandle._quatHelper)
                .premultiply(parentWorldQuaternionInverse);
        }
        else {
            // No parent, world space = local space
            position.copy(DistanceGrabHandle._posHelper);
            quaternion.copy(DistanceGrabHandle._quatHelper);
        }
        // Always apply during drag; if returnToOrigin is true,
        // the override in apply() will snap back on release.
        this.outputState.update(this.latestMoveEvent, {
            pointerAmount,
            position,
            quaternion,
            rotation,
            scale,
            time,
        });
        this.outputState.memo = this.apply(target);
        this.latestMoveEvent = undefined;
    }
    apply(target) {
        var _a;
        // On release (last frame), if configured to return to origin,
        // restore the initially saved transform instead of leaving the final drag state.
        if (this.returnToOrigin && ((_a = this.outputState) === null || _a === void 0 ? void 0 : _a.last)) {
            target.position.copy(this.initialTargetPosition);
            // Keep rotation order consistent when restoring
            target.rotation.order = this.initialTargetRotation.order;
            target.quaternion.copy(this.initialTargetQuaternion);
            target.scale.copy(this.initialTargetScale);
            // Do not call super.apply to avoid re-applying the drag transform.
            return undefined;
        }
        return super.apply(target);
    }
}
DistanceGrabHandle._tmp = new Vector3();
DistanceGrabHandle._posHelper = new Vector3();
DistanceGrabHandle._quatHelper = new Quaternion();

export { DistanceGrabHandle, Handle, MovementMode };
//# sourceMappingURL=handles.js.map
