/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
declare const GrabSystem_base: import("elics").SystemConstructor<import("elics").SystemSchema, {
    oneHandGrabbables: {
        required: import("elics").Component<{
            rotate: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            rotateMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            rotateMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            translate: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            translateMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            translateMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
        }>[];
    };
    twoHandsGrabbables: {
        required: import("elics").Component<{
            rotate: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            rotateMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            rotateMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            translate: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            translateMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            translateMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            scale: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            scaleMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            scaleMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
        }>[];
    };
    distanceGrabbables: {
        required: import("elics").Component<{
            rotate: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            rotateMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            rotateMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            translate: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            translateMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            translateMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            scale: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            scaleMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            scaleMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            movementMode: {
                type: import("elics/lib/types.js").Types.Enum;
                enum: {
                    MoveFromTarget: string;
                    MoveTowardsTarget: string;
                    MoveAtSource: string;
                    RotateAtSource: string;
                };
                default: string;
            };
            returnToOrigin: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: false;
            };
            moveSpeed: {
                type: import("elics/lib/types.js").Types.Float32;
                default: number;
            };
        }>[];
    };
    handles: {
        required: import("elics").Component<{
            instance: {
                type: import("elics/lib/types.js").Types.Object;
                default: undefined;
            };
        }>[];
    };
}, import("../ecs/world.js").World, import("../ecs/system.js").System<import("elics").SystemSchema, {
    oneHandGrabbables: {
        required: import("elics").Component<{
            rotate: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            rotateMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            rotateMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            translate: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            translateMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            translateMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
        }>[];
    };
    twoHandsGrabbables: {
        required: import("elics").Component<{
            rotate: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            rotateMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            rotateMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            translate: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            translateMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            translateMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            scale: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            scaleMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            scaleMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
        }>[];
    };
    distanceGrabbables: {
        required: import("elics").Component<{
            rotate: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            rotateMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            rotateMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            translate: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            translateMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            translateMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            scale: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: true;
            };
            scaleMax: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            scaleMin: {
                type: import("elics/lib/types.js").Types.Vec3;
                default: [number, number, number];
            };
            movementMode: {
                type: import("elics/lib/types.js").Types.Enum;
                enum: {
                    MoveFromTarget: string;
                    MoveTowardsTarget: string;
                    MoveAtSource: string;
                    RotateAtSource: string;
                };
                default: string;
            };
            returnToOrigin: {
                type: import("elics/lib/types.js").Types.Boolean;
                default: false;
            };
            moveSpeed: {
                type: import("elics/lib/types.js").Types.Float32;
                default: number;
            };
        }>[];
    };
    handles: {
        required: import("elics").Component<{
            instance: {
                type: import("elics/lib/types.js").Types.Object;
                default: undefined;
            };
        }>[];
    };
}>>;
/**
 * Manages interactive object grabbing and manipulation for VR/AR experiences.
 *
 * @remarks
 * - Uses the `@pmndrs/handle` library for precise multitouch manipulation.
 * - Automatically creates handle instances for entities with grabbable components.
 * - Supports three types of grab interactions: one‑hand, two‑hand, and distance grabbing.
 * - Automatically cleans up handle instances when grabbable components are removed.
 *
 * @example Basic grab system setup
 * ```ts
 * // Add to your world to enable grab interactions
 * world.addSystem(GrabSystem)
 *
 * // Create a grabbable box
 * const box = world.createEntity()
 * box.addComponent(OneHandGrabbable, {})
 * ```
 *
 * @example Two‑handed manipulation
 * ```ts
 * // Create an object that can be scaled with two hands
 * const sculpture = world.createEntity()
 * sculpture.addComponent(TwoHandsGrabbable, {
 *   scaleMin: [0.5, 0.5, 0.5],
 *   scaleMax: [3, 3, 3]
 * })
 * ```
 *
 * @category Grab
 * @see {@link OneHandGrabbable}
 * @see {@link TwoHandsGrabbable}
 * @see {@link DistanceGrabbable}
 */
export declare class GrabSystem extends GrabSystem_base {
    init(): void;
    update(delta: number): void;
    private initializeOneHandHandle;
    private initializeTwoHandsHandle;
    private initializeDistanceHandle;
}
export {};
//# sourceMappingURL=grab-system.d.ts.map