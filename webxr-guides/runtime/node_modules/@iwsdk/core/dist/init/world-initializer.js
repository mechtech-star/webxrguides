import { XRInputManager } from '@iwsdk/xr-input';
import { signal } from '@preact/signals-core';
import { AssetManager } from '../asset/asset-manager.js';
import '../asset/cache-manager.js';
import { AudioSource } from '../audio/audio.js';
import { AudioSystem } from '../audio/audio-system.js';
import '../runtime/three.js';
import '../camera/camera-utils.js';
import { CameraSource } from '../camera/camera-source.js';
import { CameraSystem } from '../camera/camera-system.js';
import { World, VisibilityState } from '../ecs/world.js';
import 'elics';
import '../ecs/component-registry.js';
import { DomeTexture } from '../environment/dome-texture.js';
import { DomeGradient } from '../environment/dome-gradient.js';
import { IBLTexture } from '../environment/ibl-texture.js';
import { IBLGradient } from '../environment/ibl-gradient.js';
import { EnvironmentSystem } from '../environment/environment-system.js';
import '../grab/index.js';
import { InputSystem } from '../input/input-system.js';
import { Interactable, Hovered, Pressed } from '../input/state-tags.js';
import { LevelSystem } from '../level/level-system.js';
import { LevelTag } from '../level/level-tag.js';
import '@iwsdk/glxf';
import '@pmndrs/uikit';
import { PerspectiveCamera, WebGLRenderer, SRGBColorSpace, Scene, Clock } from 'three';
import { PanelUI, PanelUISystem } from '../ui/ui.js';
import { Follower, FollowSystem } from '../ui/follow.js';
import { ScreenSpace, ScreenSpaceUISystem } from '../ui/screenspace.js';
import { LevelRoot } from '../level/level-root.js';
import '../locomotion/slide.js';
import '../locomotion/teleport.js';
import '../locomotion/turn.js';
import { LocomotionSystem } from '../locomotion/locomotion.js';
import { PhysicsSystem } from '../physics/physics-system.js';
import { PhysicsBody } from '../physics/physicsBody.js';
import { PhysicsManipulation } from '../physics/physicsManipulation.js';
import { PhysicsShape } from '../physics/physicsShape.js';
import { SceneUnderstandingSystem } from '../scene-understanding/scene-understanding-system.js';
import { XRAnchor } from '../scene-understanding/anchor.js';
import { XRPlane } from '../scene-understanding/plane.js';
import { XRMesh } from '../scene-understanding/mesh.js';
import { Transform, TransformSystem } from '../transform/transform.js';
import { Visibility, VisibilitySystem } from '../visibility/visibility.js';
import { ReferenceSpaceType, SessionMode, buildSessionInit, normalizeReferenceSpec, resolveReferenceSpaceType } from './xr.js';
import { GrabSystem } from '../grab/grab-system.js';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Initialize a new WebXR world with all required systems and setup
 *
 * @param sceneContainer - HTML container for the renderer canvas
 * @param assets - Asset manifest for preloading
 * @param options - Configuration options for the world
 * @returns Promise that resolves to the initialized World instance
 */
/**
 * Initialize a new WebXR world with all required systems and setup.
 *
 * @param sceneContainer HTML container for the renderer canvas.
 * @param options Configuration options for the world.
 * @returns Promise that resolves to the initialized {@link World} instance.
 *
 * @remarks
 * This function powers {@link World.create}. Prefer using that static helper.
 */
function initializeWorld(container, options = {}) {
    // Create and configure world instance
    const world = createWorldInstance();
    // Extract configuration options
    const config = extractConfiguration(options);
    // Setup core rendering components
    const { camera, renderer, scene } = setupRendering(container, config);
    assignRenderingToWorld(world, camera, renderer, scene);
    // Setup input management
    setupInputManagement(world);
    // Store XR defaults for later explicit launch/offer calls
    world.xrDefaults = {
        sessionMode: config.xr.sessionMode,
        referenceSpace: config.xr.referenceSpace,
        features: config.xr.features,
    };
    // Register core systems (LevelSystem receives defaultLighting)
    registerCoreSystems(world, config);
    // Initialize asset manager
    initializeAssetManager(renderer, world);
    // Register additional systems (UI + Audio on by default)
    registerAdditionalSystems(world);
    // Register input and feature systems with explicit priorities
    registerFeatureSystems(world, config);
    // Setup render loop
    setupRenderLoop(world, renderer);
    // Setup resize handling
    setupResizeHandling(camera, renderer);
    // Manage XR offer flow if configured
    if (config.xr.offer && config.xr.offer !== 'none') {
        manageOfferFlow(world, config.xr.offer);
    }
    // Return promise that resolves after asset preloading
    return finalizeInitialization(world, options.assets).then(async (w) => {
        var _a;
        // Load initial level or create empty level
        const levelUrl = typeof options.level === 'string' ? options.level : (_a = options.level) === null || _a === void 0 ? void 0 : _a.url;
        if (levelUrl) {
            await w.loadLevel(levelUrl);
        }
        else {
            await w.loadLevel();
        }
        return w;
    });
}
/**
 * Create a new World instance with basic ECS setup
 */
function createWorldInstance() {
    const world = new World();
    world
        .registerComponent(Transform)
        .registerComponent(Visibility)
        .registerComponent(LevelTag)
        .registerSystem(TransformSystem)
        .registerSystem(VisibilitySystem);
    return world;
}
/**
 * Extract and normalize configuration options
 */
function extractConfiguration(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2;
    return {
        cameraFov: (_b = (_a = options.render) === null || _a === void 0 ? void 0 : _a.fov) !== null && _b !== void 0 ? _b : 50,
        cameraNear: (_d = (_c = options.render) === null || _c === void 0 ? void 0 : _c.near) !== null && _d !== void 0 ? _d : 0.1,
        cameraFar: (_f = (_e = options.render) === null || _e === void 0 ? void 0 : _e.far) !== null && _f !== void 0 ? _f : 200,
        defaultLighting: (_h = (_g = options.render) === null || _g === void 0 ? void 0 : _g.defaultLighting) !== null && _h !== void 0 ? _h : true,
        xr: {
            sessionMode: (_k = (_j = options.xr) === null || _j === void 0 ? void 0 : _j.sessionMode) !== null && _k !== void 0 ? _k : SessionMode.ImmersiveVR,
            referenceSpace: (_m = (_l = options.xr) === null || _l === void 0 ? void 0 : _l.referenceSpace) !== null && _m !== void 0 ? _m : ReferenceSpaceType.LocalFloor,
            features: (_o = options.xr) === null || _o === void 0 ? void 0 : _o.features,
            offer: (_q = (_p = options.xr) === null || _p === void 0 ? void 0 : _p.offer) !== null && _q !== void 0 ? _q : 'always',
        },
        features: {
            locomotion: (_s = (_r = options.features) === null || _r === void 0 ? void 0 : _r.locomotion) !== null && _s !== void 0 ? _s : false,
            grabbing: (_u = (_t = options.features) === null || _t === void 0 ? void 0 : _t.grabbing) !== null && _u !== void 0 ? _u : false,
            physics: (_w = (_v = options.features) === null || _v === void 0 ? void 0 : _v.physics) !== null && _w !== void 0 ? _w : false,
            sceneUnderstanding: (_y = (_x = options.features) === null || _x === void 0 ? void 0 : _x.sceneUnderstanding) !== null && _y !== void 0 ? _y : false,
            camera: (_0 = (_z = options.features) === null || _z === void 0 ? void 0 : _z.camera) !== null && _0 !== void 0 ? _0 : false,
            spatialUI: (_2 = (_1 = options.features) === null || _1 === void 0 ? void 0 : _1.spatialUI) !== null && _2 !== void 0 ? _2 : true,
        },
    };
}
/**
 * Setup camera, renderer, and scene
 */
function setupRendering(sceneContainer, config) {
    // Camera Setup
    const camera = new PerspectiveCamera(config.cameraFov, window.innerWidth / window.innerHeight, config.cameraNear, config.cameraFar);
    camera.position.set(0, 1.7, 0);
    // Renderer Setup
    const renderer = new WebGLRenderer({
        antialias: true,
        alpha: config.xr.sessionMode === SessionMode.ImmersiveAR,
        // @ts-ignore
        multiviewStereo: true,
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = SRGBColorSpace;
    renderer.xr.enabled = true;
    sceneContainer.appendChild(renderer.domElement);
    // Scene Setup
    const scene = new Scene();
    return { camera, renderer, scene };
}
/**
 * Assign rendering components to world instance
 */
function assignRenderingToWorld(world, camera, renderer, scene) {
    world.scene = scene;
    world.camera = camera;
    world.renderer = renderer;
    // Scene entity (wrap Scene in an entity for parenting convenience)
    world.sceneEntity = world.createTransformEntity(scene);
    // Create a default level root so activeLevel is always defined
    const levelRootEntity = world.createTransformEntity(undefined, {
        parent: world.sceneEntity,
    });
    levelRootEntity.object3D.name = 'LevelRoot';
    // @ts-ignore init signal now; LevelSystem will enforce identity each frame
    world.activeLevel = signal(levelRootEntity);
}
/**
 * Setup default lighting environment using Unity-style gradient ambient lighting
 */
// default lighting is attached per level by LevelSystem
/**
 * Setup XR input management
 */
function setupInputManagement(world) {
    const inputManager = new XRInputManager({
        camera: world.camera,
        scene: world.scene,
        assetLoader: AssetManager,
    });
    world.scene.add(inputManager.xrOrigin);
    inputManager.xrOrigin.add(world.camera);
    world.player = inputManager.xrOrigin;
    world.input = inputManager;
    return inputManager;
}
/**
 * Manage offering XR sessions according to the configured offer policy.
 * - 'once': offer after init; no re-offer on end
 * - 'always': offer after init and re-offer whenever the session ends
 */
function manageOfferFlow(world, mode) {
    let offering = false;
    const offer = async () => {
        var _a, _b, _c, _d;
        if (offering || world.session) {
            return;
        }
        offering = true;
        try {
            const opts = (_a = world.xrDefaults) !== null && _a !== void 0 ? _a : { sessionMode: SessionMode.ImmersiveVR };
            const sessionInit = buildSessionInit(opts);
            const session = await ((_c = (_b = navigator.xr) === null || _b === void 0 ? void 0 : _b.offerSession) === null || _c === void 0 ? void 0 : _c.call(_b, (_d = opts.sessionMode) !== null && _d !== void 0 ? _d : SessionMode.ImmersiveVR, 
            // if the dynamic import failed, rebuild via launchXR path by calling request, but we only want offer
            sessionInit));
            if (!session) {
                return;
            }
            const refSpec = normalizeReferenceSpec(opts.referenceSpace);
            session.addEventListener('end', onEnd);
            try {
                const resolvedType = await resolveReferenceSpaceType(session, refSpec.type, refSpec.required ? [] : refSpec.fallbackOrder);
                world.renderer.xr.setReferenceSpaceType(resolvedType);
                await world.renderer.xr.setSession(session);
                world.session = session;
            }
            catch (err) {
                console.error('[XR] Failed to acquire reference space:', err);
                try {
                    await session.end();
                }
                catch (_e) { }
            }
        }
        finally {
            offering = false;
        }
    };
    const onEnd = () => {
        var _a;
        (_a = world.session) === null || _a === void 0 ? void 0 : _a.removeEventListener('end', onEnd);
        world.session = undefined;
        if (mode === 'always') {
            // re-offer after session ends
            offer();
        }
    };
    // initial offer once world is ready
    offer();
}
/**
 * Register core interaction systems
 */
function registerCoreSystems(world, config) {
    world
        .registerComponent(Interactable)
        .registerComponent(Hovered)
        .registerComponent(Pressed)
        .registerComponent(LevelRoot)
        // New split components
        .registerComponent(DomeTexture)
        .registerComponent(DomeGradient)
        .registerComponent(IBLTexture)
        .registerComponent(IBLGradient)
        // Unified environment system (background + IBL)
        .registerSystem(EnvironmentSystem)
        .registerSystem(LevelSystem, {
        configData: { defaultLighting: config.defaultLighting },
    });
}
/**
 * Initialize the asset manager
 */
function initializeAssetManager(renderer, world) {
    AssetManager.init(renderer, world);
}
/**
 * Register optional systems based on configuration
 */
function registerAdditionalSystems(world) {
    // Audio system remains always-on
    world.registerComponent(AudioSource).registerSystem(AudioSystem);
}
function registerFeatureSystems(world, config) {
    const locomotion = config.features.locomotion;
    const locomotionEnabled = !!locomotion;
    const grabbingEnabled = !!config.features.grabbing;
    const physicsEnabled = !!config.features.physics;
    const sceneUnderstanding = config.features.sceneUnderstanding;
    const sceneUnderstandingEnabled = !!sceneUnderstanding;
    const cameraEnabled = !!config.features.camera;
    const spatialUI = config.features.spatialUI;
    const spatialUIEnabled = !!spatialUI;
    if (locomotionEnabled) {
        const locOpts = typeof locomotion === 'object' && locomotion
            ? { useWorker: locomotion.useWorker }
            : undefined;
        world.registerSystem(LocomotionSystem, {
            priority: -5,
            configData: locOpts,
        });
    }
    world.registerSystem(InputSystem, { priority: -4 });
    if (grabbingEnabled) {
        world.registerSystem(GrabSystem, { priority: -3 });
    }
    // Physics runs after Grab so it can respect Pressed overrides
    if (physicsEnabled) {
        world
            .registerComponent(PhysicsBody)
            .registerComponent(PhysicsShape)
            .registerComponent(PhysicsManipulation)
            .registerSystem(PhysicsSystem, { priority: -2 });
    }
    // Scene Understanding updates plane/mesh/anchor debug after input/physics
    if (sceneUnderstandingEnabled) {
        const sceneOpts = typeof sceneUnderstanding === 'object' && sceneUnderstanding
            ? { showWireFrame: sceneUnderstanding.showWireFrame }
            : undefined;
        world
            .registerComponent(XRPlane)
            .registerComponent(XRMesh)
            .registerComponent(XRAnchor)
            .registerSystem(SceneUnderstandingSystem, {
            priority: -1,
            configData: sceneOpts,
        });
    }
    // Camera system for video streaming
    if (cameraEnabled) {
        world.registerComponent(CameraSource).registerSystem(CameraSystem);
    }
    // Spatial UI systems (Panel, ScreenSpace, Follow)
    if (spatialUIEnabled) {
        const forwardHtmlEvents = typeof spatialUI === 'object' && spatialUI
            ? spatialUI.forwardHtmlEvents
            : undefined;
        const kitsVal = typeof spatialUI === 'object' && spatialUI ? spatialUI.kits : undefined;
        const kitsObj = Array.isArray(kitsVal)
            ? Object.assign({}, ...kitsVal)
            : kitsVal;
        const preferredColorScheme = typeof spatialUI === 'object' && spatialUI
            ? spatialUI.preferredColorScheme
            : undefined;
        world
            .registerComponent(PanelUI)
            .registerComponent(ScreenSpace)
            .registerComponent(Follower)
            .registerSystem(PanelUISystem, {
            configData: {
                ...(forwardHtmlEvents !== undefined ? { forwardHtmlEvents } : {}),
                ...(kitsObj ? { kits: kitsObj } : {}),
                ...(preferredColorScheme !== undefined ? { preferredColorScheme } : {}),
            },
        })
            .registerSystem(ScreenSpaceUISystem)
            .registerSystem(FollowSystem);
    }
}
/**
 * Setup the main render loop
 */
function setupRenderLoop(world, renderer) {
    const clock = new Clock();
    const render = () => {
        var _a, _b;
        const delta = clock.getDelta();
        const elapsedTime = clock.elapsedTime;
        world.visibilityState.value = ((_b = (_a = world.session) === null || _a === void 0 ? void 0 : _a.visibilityState) !== null && _b !== void 0 ? _b : VisibilityState.NonImmersive);
        // Run ECS systems in priority order (InputSystem => LocomotionSystem => GrabSystem)
        world.update(delta, elapsedTime);
        renderer.render(world.scene, world.camera);
    };
    renderer.setAnimationLoop(render);
    // No explicit sessionend handling required on r177; WebXRManager handles
    // render target and canvas sizing restoration internally.
}
/**
 * Setup window resize handling
 */
function setupResizeHandling(camera, renderer) {
    const onWindowResize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', onWindowResize, false);
}
/**
 * Finalize initialization with asset preloading
 */
function finalizeInitialization(world, assets) {
    return new Promise((resolve, reject) => {
        if (!assets || Object.keys(assets).length === 0) {
            return resolve(world);
        }
        AssetManager.preloadAssets(assets)
            .then(() => resolve(world))
            .catch(reject);
    });
}

export { initializeWorld };
//# sourceMappingURL=world-initializer.js.map
