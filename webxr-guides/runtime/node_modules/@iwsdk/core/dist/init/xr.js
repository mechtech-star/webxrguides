/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** WebXR session modes supported by IWSDK. @category Runtime */
var SessionMode;
(function (SessionMode) {
    SessionMode["ImmersiveVR"] = "immersive-vr";
    SessionMode["ImmersiveAR"] = "immersive-ar";
})(SessionMode || (SessionMode = {}));
/** Common WebXR reference spaces. @category Runtime */
var ReferenceSpaceType;
(function (ReferenceSpaceType) {
    ReferenceSpaceType["BoundedFloor"] = "bounded-floor";
    ReferenceSpaceType["Local"] = "local";
    ReferenceSpaceType["LocalFloor"] = "local-floor";
    ReferenceSpaceType["Unbounded"] = "unbounded";
    ReferenceSpaceType["Viewer"] = "viewer";
})(ReferenceSpaceType || (ReferenceSpaceType = {}));
/** Default optional features appended to requests/offers. */
const defaultOffers = ['local-floor', 'bounded-floor', 'layers'];
/** Normalize a {@link FeatureFlag} to `{ required?: boolean } | undefined`. */
function normalizeFlag(flag) {
    if (flag === undefined || flag === false) {
        return undefined;
    }
    if (flag === true) {
        return {};
    }
    return { required: !!flag.required };
}
function isDepthFlagObject(flag) {
    return typeof flag === 'object';
}
/** Build `XRSessionInit` from structured feature flags. */
function buildSessionInit(opts) {
    var _a;
    const requiredFeatures = [];
    // Always offer helpful optional features by default
    const optionalFeatures = Array.from(new Set(defaultOffers));
    const f = (_a = opts.features) !== null && _a !== void 0 ? _a : {};
    const map = {
        handTracking: 'hand-tracking',
        anchors: 'anchors',
        hitTest: 'hit-test',
        planeDetection: 'plane-detection',
        meshDetection: 'mesh-detection',
        lightEstimation: 'light-estimation',
        depthSensing: 'depth-sensing',
        layers: 'layers',
    };
    const push = (key, normalized) => {
        if (!normalized) {
            return;
        }
        const token = map[key];
        if (normalized.required) {
            requiredFeatures.push(token);
        }
        else {
            optionalFeatures.push(token);
        }
    };
    // Simple flags
    push('handTracking', normalizeFlag(f.handTracking));
    push('anchors', normalizeFlag(f.anchors));
    push('hitTest', normalizeFlag(f.hitTest));
    push('planeDetection', normalizeFlag(f.planeDetection));
    push('meshDetection', normalizeFlag(f.meshDetection));
    push('lightEstimation', normalizeFlag(f.lightEstimation));
    push('layers', normalizeFlag(f.layers));
    // Depth sensing (may include preferences)
    if (f.depthSensing) {
        const normalized = normalizeFlag(isDepthFlagObject(f.depthSensing)
            ? { required: f.depthSensing.required }
            : f.depthSensing);
        push('depthSensing', normalized);
    }
    const sessionInit = {
        requiredFeatures: Array.from(new Set(requiredFeatures)),
        optionalFeatures: Array.from(new Set(optionalFeatures)),
    };
    if (isDepthFlagObject(f.depthSensing)) {
        const usage = f.depthSensing.usage
            ? [f.depthSensing.usage]
            : undefined;
        const format = f.depthSensing.format
            ? [f.depthSensing.format]
            : undefined;
        // Use DOM XRDepthStateInit typing where available
        sessionInit.depthSensing = {
            ...(usage ? { usagePreference: usage } : {}),
            ...(format ? { dataFormatPreference: format } : {}),
        };
    }
    return sessionInit;
}
function normalizeReferenceSpec(spec) {
    var _a, _b, _c;
    if (!spec || typeof spec === 'string') {
        return {
            type: (_a = spec) !== null && _a !== void 0 ? _a : ReferenceSpaceType.LocalFloor,
            required: false,
            fallbackOrder: [ReferenceSpaceType.Local, ReferenceSpaceType.Viewer],
        };
    }
    return {
        type: (_b = spec.type) !== null && _b !== void 0 ? _b : ReferenceSpaceType.LocalFloor,
        required: !!spec.required,
        fallbackOrder: (_c = spec.fallbackOrder) !== null && _c !== void 0 ? _c : [
            ReferenceSpaceType.Local,
            ReferenceSpaceType.Viewer,
        ],
    };
}
function mergeXROptions(base, overrides) {
    var _a, _b, _c, _d, _e;
    const b = base !== null && base !== void 0 ? base : {};
    const o = overrides !== null && overrides !== void 0 ? overrides : {};
    const mergedFeatures = { ...((_a = b.features) !== null && _a !== void 0 ? _a : {}), ...((_b = o.features) !== null && _b !== void 0 ? _b : {}) };
    const merged = {
        sessionMode: (_d = (_c = o.sessionMode) !== null && _c !== void 0 ? _c : b.sessionMode) !== null && _d !== void 0 ? _d : SessionMode.ImmersiveVR,
        referenceSpace: (_e = o.referenceSpace) !== null && _e !== void 0 ? _e : b.referenceSpace,
        features: Object.keys(mergedFeatures).length ? mergedFeatures : undefined,
    };
    return merged;
}
async function resolveReferenceSpaceType(session, preferred, fallbacks) {
    const candidates = [];
    for (const t of [preferred, ...fallbacks]) {
        if (!candidates.includes(t)) {
            candidates.push(t);
        }
    }
    for (const type of candidates) {
        try {
            // Probe support; three.js will request again using the resolved type.
            await session.requestReferenceSpace(type);
            return type;
        }
        catch (_err) {
            // continue
        }
    }
    // If nothing worked, throw; caller will end the session.
    throw new Error('No supported reference space available');
}
/**
 * Explicitly request a WebXR session with the given options.
 *
 * @param world Target world.
 * @param options Partial overrides merged with {@link World.xrDefaults}.
 * @category Runtime
 */
function launchXR(world, options) {
    var _a, _b;
    const merged = mergeXROptions(world.xrDefaults, options);
    const { sessionMode = SessionMode.ImmersiveVR } = merged;
    const refSpec = normalizeReferenceSpec(merged.referenceSpace);
    const sessionOptions = buildSessionInit(merged);
    const onSessionStart = async (session) => {
        session.addEventListener('end', onSessionEnd);
        try {
            const resolvedType = await resolveReferenceSpaceType(session, refSpec.type, refSpec.required ? [] : refSpec.fallbackOrder);
            world.renderer.xr.setReferenceSpaceType(resolvedType);
            await world.renderer.xr.setSession(session);
            world.session = session;
        }
        catch (err) {
            console.error('[XR] Failed to acquire reference space:', err);
            try {
                await session.end();
            }
            catch (_a) { }
        }
    };
    const onSessionEnd = () => {
        var _a;
        (_a = world.session) === null || _a === void 0 ? void 0 : _a.removeEventListener('end', onSessionEnd);
        world.session = undefined;
    };
    if (!world.session) {
        (_b = (_a = navigator.xr) === null || _a === void 0 ? void 0 : _a.requestSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionMode, sessionOptions).then(onSessionStart);
    }
    else {
        console.error('XRSession already exists');
    }
}

export { ReferenceSpaceType, SessionMode, buildSessionInit, launchXR, normalizeReferenceSpec, resolveReferenceSpaceType };
//# sourceMappingURL=xr.js.map
