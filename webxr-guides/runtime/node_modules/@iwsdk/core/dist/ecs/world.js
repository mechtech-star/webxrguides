import { signal } from '@preact/signals-core';
import { World as World$1 } from 'elics';
import { launchXR } from '../init/xr.js';
import { initializeWorld } from '../init/world-initializer.js';
import '../level/level-system.js';
import { LevelTag } from '../level/level-tag.js';
import '@iwsdk/glxf';
import '../asset/asset-manager.js';
import '../asset/cache-manager.js';
import './component-registry.js';
import '@pmndrs/uikit';
import { Object3D } from 'three';
import '../ui/ui.js';
import '../ui/follow.js';
import '../ui/screenspace.js';
import '../level/level-root.js';
import '../runtime/three.js';
import { Transform } from '../transform/transform.js';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VisibilityState;
(function (VisibilityState) {
    VisibilityState["NonImmersive"] = "non-immersive";
    VisibilityState["Hidden"] = "hidden";
    VisibilityState["Visible"] = "visible";
    VisibilityState["VisibleBlurred"] = "visible-blurred";
})(VisibilityState || (VisibilityState = {}));
/**
 * World is the root ECS container, Three.js scene/renderer owner, and XR session gateway.
 *
 * @remarks
 * - Construct a world with {@link World.create} (recommended) which wires the renderer, scene, default systems
 *   (Input, UI, Audio, Level) and starts the render loop.
 * - The world exposes convenience handles like {@link World.input | input} (XRInputManager),
 *   {@link World.player | player} (XROrigin), and {@link World.assetManager}.
 * - Feature systems (Grabbing, Locomotion) are optâ€‘in via {@link WorldOptions.features}.
 *
 * @category Runtime
 * @example
 * ```ts
 * import { World, SessionMode } from '@iwsdk/core';
 *
 * const container = document.getElementById('scene-container') as HTMLDivElement;
 * const world = await World.create(container, {
 *   xr: { sessionMode: SessionMode.ImmersiveVR },
 *   features: { enableLocomotion: true, enableGrabbing: true },
 *   level: '/glxf/Composition.glxf'
 * });
 * ```
 */
class World extends World$1 {
    constructor() {
        super();
        this.activeLevelId = 'level:default';
        this.visibilityState = signal(VisibilityState.NonImmersive);
        const originalReleaseFunc = this.entityManager.releaseEntityInstance.bind(this.entityManager);
        this.entityManager.releaseEntityInstance = (entity) => {
            var _a;
            originalReleaseFunc(entity);
            (_a = entity.object3D) === null || _a === void 0 ? void 0 : _a.removeFromParent();
            delete entity.object3D;
        };
    }
    createEntity() {
        return super.createEntity();
    }
    createTransformEntity(object, parentOrOptions) {
        var _a, _b;
        const entity = super.createEntity();
        const obj = object !== null && object !== void 0 ? object : new Object3D();
        // Cast to pointer-events-capable Object3D event map for downstream typing
        entity.object3D = obj;
        let parent = undefined;
        let persistent = false;
        if (parentOrOptions) {
            if (typeof parentOrOptions.index === 'number') {
                parent = parentOrOptions;
            }
            else {
                const opts = parentOrOptions;
                parent = opts.parent;
                persistent = !!opts.persistent;
            }
        }
        if (!parent) {
            // Avoid self-parenting for the Scene root
            const isSceneObject = (obj) => obj.isScene === true;
            if (object && isSceneObject(object)) {
                parent = undefined;
                persistent = true;
            }
            else {
                parent = persistent
                    ? this.sceneEntity
                    : ((_b = (_a = this.activeLevel) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : this.sceneEntity);
            }
        }
        entity.addComponent(Transform, { parent });
        // Tag entity with current level, unless persistent
        if (!persistent) {
            entity.addComponent(LevelTag, { id: this.activeLevelId });
        }
        return entity;
    }
    launchXR(xrOptions) {
        launchXR(this, xrOptions);
    }
    /** Request a level change; LevelSystem performs the work and resolves. */
    async loadLevel(url) {
        this.requestedLevelUrl = url !== null && url !== void 0 ? url : '';
        return new Promise((resolve) => {
            this._resolveLevelLoad = resolve;
        });
    }
    exitXR() {
        var _a;
        (_a = this.session) === null || _a === void 0 ? void 0 : _a.end();
    }
    update(delta, time) {
        super.update(delta, time);
    }
    registerComponent(component) {
        return super.registerComponent(component);
    }
    // Level root helpers
    getActiveRoot() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.activeLevel) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.object3D) !== null && _c !== void 0 ? _c : this.scene;
    }
    getPersistentRoot() {
        return this.scene;
    }
    /**
     * Initialize a new WebXR world with all required systems and setup
     *
     * @param sceneContainer - HTML container for the renderer canvas
     * @param assets - Asset manifest for preloading
     * @param options - Configuration options for the world
     * @returns Promise that resolves to the initialized World instance
     */
    /**
     * Initialize a new WebXR world with renderer, scene, default systems, and optional level.
     *
     * @param container HTML container to which the renderer canvas will be appended.
     * @param options Runtime configuration, see {@link WorldOptions}.
     * @returns A promise that resolves to the initialized {@link World}.
     *
     * @remarks
     * - This call enables the Input, UI and Audio systems by default.
     * - Use {@link WorldOptions.features} to enable Locomotion or Grabbing.
     * - If {@link WorldOptions.level} is provided, the LevelSystem will load it after assets are preloaded.
     * @see /getting-started/01-hello-xr
     */
    static create(container, options) {
        return initializeWorld(container, options);
    }
}

export { VisibilityState, World };
//# sourceMappingURL=world.js.map
