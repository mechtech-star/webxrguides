/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Type declarations for WebXR Anchors API persistence features.
 *
 * These extensions to the WebXR Device API allow anchors to persist across sessions,
 * enabling virtual objects to maintain their real-world positions even after the
 * application is closed and reopened.
 *
 * @see {@link https://github.com/immersive-web/anchors/blob/main/explainer.md WebXR Anchors Module}
 */
declare global {
    interface XRAnchor {
        /**
         * Requests a persistent handle (UUID) for this anchor.
         * The UUID can be used with restorePersistentAnchor() to restore the anchor in future sessions.
         */
        requestPersistentHandle(): Promise<string>;
        /**
         * Deletes this anchor, removing it from tracking.
         */
        delete(): void;
    }
    interface XRSession {
        /**
         * Array of UUIDs for all persistent anchors available in this session.
         */
        readonly persistentAnchors: readonly string[];
        /**
         * Restores a previously created persistent anchor using its UUID.
         * @param uuid - The persistent handle returned from requestPersistentHandle()
         * @returns The restored anchor, or rejects if the anchor cannot be found
         */
        restorePersistentAnchor(uuid: string): Promise<XRAnchor>;
        /**
         * Permanently deletes a persistent anchor.
         * @param uuid - The persistent handle of the anchor to delete
         */
        deletePersistentAnchor(uuid: string): Promise<void>;
    }
}
import { Types } from '../ecs/index.js';
declare const SceneUnderstandingSystem_base: import("elics").SystemConstructor<{
    showWireFrame: {
        type: Types.Boolean;
        default: false;
    };
}, {
    planeEntities: {
        required: import("elics").Component<{
            _plane: {
                type: Types.Object;
                default: undefined;
            };
        }>[];
    };
    meshEntities: {
        required: import("elics").Component<{
            _mesh: {
                type: Types.Object;
                default: undefined;
            };
            isBounded3D: {
                type: Types.Boolean;
                default: false;
            };
            semanticLabel: {
                type: Types.String;
                default: string;
            };
            min: {
                type: Types.Vec3;
                default: [number, number, number];
            };
            max: {
                type: Types.Vec3;
                default: [number, number, number];
            };
            dimensions: {
                type: Types.Vec3;
                default: [number, number, number];
            };
        }>[];
    };
    anchoredEntities: {
        required: import("elics").Component<{
            attached: {
                type: Types.Boolean;
                default: false;
            };
        }>[];
    };
}, import("../ecs/world.js").World, import("../ecs/system.js").System<{
    showWireFrame: {
        type: Types.Boolean;
        default: false;
    };
}, {
    planeEntities: {
        required: import("elics").Component<{
            _plane: {
                type: Types.Object;
                default: undefined;
            };
        }>[];
    };
    meshEntities: {
        required: import("elics").Component<{
            _mesh: {
                type: Types.Object;
                default: undefined;
            };
            isBounded3D: {
                type: Types.Boolean;
                default: false;
            };
            semanticLabel: {
                type: Types.String;
                default: string;
            };
            min: {
                type: Types.Vec3;
                default: [number, number, number];
            };
            max: {
                type: Types.Vec3;
                default: [number, number, number];
            };
            dimensions: {
                type: Types.Vec3;
                default: [number, number, number];
            };
        }>[];
    };
    anchoredEntities: {
        required: import("elics").Component<{
            attached: {
                type: Types.Boolean;
                default: false;
            };
        }>[];
    };
}>>;
/**
 * Manages WebXR scene understanding features including plane detection, mesh detection, and anchoring.
 *
 * @remarks
 * - Automatically detects and visualizes real‑world planes and meshes in AR/VR environments.
 * - Creates entities with {@link XRPlane} components for detected planes (floors, walls, ceilings).
 * - Creates entities with {@link XRMesh} components for detected 3D geometry.
 * - Supports anchoring objects to real‑world positions using {@link XRAnchor} components.
 * - Requires WebXR session features: 'plane‑detection', 'mesh‑detection', 'anchor' when using the related features.
 * - Automatically manages entity lifecycle as real‑world geometry changes.
 * - Provides optional visual feedback with wireframe meshes for detected geometry.
 * - Objects with {@link XRAnchor} are automatically attached to a stable world‑anchored group.
 *
 * @example Basic scene understanding setup
 * ```ts
 * // WebXR session must request required features
 * World.create(document.getElementById('scene-container'), {
 *   assets,
 *   xr: {
 *     sessionMode: SessionMode.ImmersiveAR,
 *     features: { planeDetection: true, meshDetection: true, anchors: true },
 *   }
 * })
 *
 * // Add to your world to enable scene understanding
 * world.addSystem(SceneUnderstandingSystem)
 *

 * ```
 *
 * @example Create an anchored object
 * ```ts
 * const cube = world.createTransformEntity(cubeObject)
 * cube.addComponent(XRAnchor) // Will be anchored to real-world position
 * ```
 *
 * @example React to detected planes
 * ```ts
 * // Planes are automatically created as entities with XRPlane component
 * system.query({ required: [XRPlane] }).subscribe('qualify', (entity) => {
 *   const plane = entity.getValue(XRPlane, '_plane')
 *   console.log('New plane detected:', plane.orientation)
 * })
 * ```
 *
 * @category Scene Understanding
 * @see {@link XRPlane}
 * @see {@link XRMesh}
 * @see {@link XRAnchor}
 */
export declare class SceneUnderstandingSystem extends SceneUnderstandingSystem_base {
    private planeFeatureEnabled;
    private meshFeatureEnabled;
    private anchorFeatureEnabled;
    /** Tracks whether an anchor creation request is in progress to prevent duplicate requests */
    private anchorRequested;
    /** The current XRAnchor instance for this session. Reset on session end to prevent stale XRSpace references. */
    private xrAnchor;
    private currentPlanes;
    private currentMeshes;
    /** Group that holds all anchored objects, positioned to match the XRAnchor's world pose */
    private anchoredGroup;
    private matrixBuffer;
    /** Shared material for all plane visualization meshes */
    private planeMaterial;
    /** Shared material for all mesh visualization meshes */
    private meshMaterial;
    /** localStorage key for storing the persistent anchor UUID */
    private static readonly ANCHOR_UUID_STORAGE_KEY;
    init(): void;
    update(_delta: number, _time: number): void;
    private updatePlanes;
    private updateMeshes;
    private updateEnabledFeatures;
    /**
     * Attempts to restore a persistent anchor from a previous session.
     *
     * Persistent anchors allow anchored objects to maintain their world position
     * across XR sessions. The anchor UUID is stored in localStorage and used to
     * restore the same anchor when a new session starts.
     *
     * If restoration fails (e.g., user cleared the space, runtime doesn't support
     * persistence, or the anchor was deleted), this fails gracefully and a new
     * anchor will be created in the update loop.
     */
    private tryRestorePersistentAnchor;
    /**
     * Creates a new XR anchor at the origin of the reference space.
     *
     * The anchor is used to attach virtual objects to a stable real-world position.
     * After creation, attempts to request a persistent handle so the anchor can be
     * restored in future sessions. If persistence is not supported, the anchor
     * will only last for the current session.
     */
    private createAnchor;
    private updateAnchoredObject;
    private flatToVec3Array;
    private findMinMaxEntries;
}
export {};
//# sourceMappingURL=scene-understanding-system.d.ts.map