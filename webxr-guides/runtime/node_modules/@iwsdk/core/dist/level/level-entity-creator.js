import { ComponentRegistry, Types } from 'elics';
import '@preact/signals-core';
import '../ecs/world.js';
import '../ecs/component-registry.js';
import '@pmndrs/uikit';
import 'three';
import { PanelUI } from '../ui/ui.js';
import '../ui/follow.js';
import '../ui/screenspace.js';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** Component id prefix expected in GLXF extras. */
const PACKAGE_PREFIX = 'com.iwsdk.components.';
/**
 * Creates ECS entities from Three.js Object3D graphs and applies IWSDK components
 * found in GLXF `meta_spatial.components` extras.
 *
 * @remarks
 * - Only nodes present in the GLXF `nodes` array are converted to entities.
 * - Component ids are matched against the registry by `com.iwsdk.components.<id>`.
 * - Panel UI extras are mapped to {@link PanelUI} with JSON config paths.
 *
 * @category Scene
 */
class EntityCreator {
    static createEntitiesFromObject3D(object, nodes, parentEntity, world) {
        var _a, _b, _c, _d;
        const inNodes = nodes.includes(object);
        if (!inNodes) {
            return;
        }
        const isLevelMetaEntity = typeof object.name === 'string' && object.name.toLowerCase() === 'level';
        // Special case: a GLXF node named "level" acts as a container for level-root components.
        // Do not create a new ECS entity for it; attach its components to the existing parentEntity (level root),
        // and continue processing its children under the same parentEntity.
        if (isLevelMetaEntity && ((_b = (_a = object.userData) === null || _a === void 0 ? void 0 : _a.meta_spatial) === null || _b === void 0 ? void 0 : _b.components)) {
            this.applyComponents(parentEntity, object.userData.meta_spatial.components, world);
            // Remove the carrier node from the scene graph; it's metadata-only
            object.removeFromParent();
            return;
        }
        const entity = world.createTransformEntity(object, parentEntity);
        if ((_d = (_c = object.userData) === null || _c === void 0 ? void 0 : _c.meta_spatial) === null || _d === void 0 ? void 0 : _d.components) {
            this.applyComponents(entity, object.userData.meta_spatial.components, world);
        }
        object.children.forEach((child) => {
            this.createEntitiesFromObject3D(child, nodes, entity, world);
        });
    }
    static applyComponents(entity, glxfComponents, world) {
        const allComponents = ComponentRegistry.getAllComponents();
        this.handleMetaSpatialPanelComponents(entity, glxfComponents, world);
        Object.entries(glxfComponents).forEach(([componentName, componentData]) => {
            if (componentName === 'com.iwsdk.components.PanelUI') {
                return;
            }
            if (!componentName.startsWith(PACKAGE_PREFIX)) {
                return;
            }
            const targetId = componentName.slice(PACKAGE_PREFIX.length);
            const component = allComponents.find((comp) => comp.id === targetId);
            if (component) {
                const componentProps = this.mapGLXFDataToProps(component, componentData);
                if (!component.bitmask) {
                    world.registerComponent(component);
                }
                entity.addComponent(component, componentProps);
            }
            else {
                console.warn(`Component "${componentName}" not found in registry. Available components:`, allComponents.map((comp) => comp.id));
            }
        });
    }
    static mapGLXFDataToProps(component, glxfData) {
        const props = {};
        Object.entries(glxfData).forEach(([key, fieldData]) => {
            if (fieldData && typeof fieldData === 'object' && component.schema[key]) {
                if (component.schema[key].type === Types.Enum && 'alias' in fieldData) {
                    props[key] = fieldData.alias;
                }
                else if ('value' in fieldData) {
                    props[key] = fieldData.value;
                }
            }
        });
        return props;
    }
    static handleMetaSpatialPanelComponents(entity, glxfComponents, world) {
        var _a, _b, _c, _d, _e;
        const panelComponent = glxfComponents['com.iwsdk.components.PanelUI'];
        if (!panelComponent || !((_a = panelComponent.config) === null || _a === void 0 ? void 0 : _a.value)) {
            return;
        }
        const config = panelComponent.config.value.replace('.uikitml', '.json');
        const maxWidth = ((_c = (_b = panelComponent.maxWidth) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : 1);
        const maxHeight = ((_e = (_d = panelComponent.maxHeight) === null || _d === void 0 ? void 0 : _d.value) !== null && _e !== void 0 ? _e : 1);
        if (!PanelUI.bitmask) {
            world.registerComponent(PanelUI);
        }
        entity.addComponent(PanelUI, { config, maxWidth, maxHeight });
    }
}

export { EntityCreator };
//# sourceMappingURL=level-entity-creator.js.map
