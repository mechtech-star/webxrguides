import { createSystem } from '../ecs/system.js';
import { VisibilityState } from '../ecs/world.js';
import 'elics';
import '../ecs/component-registry.js';
import '../runtime/three.js';
import { CameraSource } from './camera-source.js';
import { CameraUtils } from './camera-utils.js';
import { CameraState, CameraFacing } from './types.js';
import { VideoTexture, LinearFilter } from 'three';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * CameraSystem - Manages camera stream lifecycle for CameraSource components
 * Automatically starts streams when XR session is active, stops when inactive
 *
 * System is stateless - all state is stored in CameraSource components
 */
class CameraSystem extends createSystem({
    cameras: { required: [CameraSource] },
}) {
    init() {
        // Stop all cameras when leaving XR
        this.world.visibilityState.subscribe((state) => {
            if (state !== VisibilityState.Visible) {
                for (const entity of this.queries.cameras.entities) {
                    this.stopCamera(entity);
                }
            }
        });
    }
    update() {
        // Only manage cameras when XR is active
        const isXRActive = this.world.visibilityState.value === VisibilityState.Visible;
        if (!isXRActive) {
            return;
        }
        for (const entity of this.queries.cameras.entities) {
            const state = entity.getValue(CameraSource, 'state');
            // Start camera if inactive (not started or errored)
            if (state === CameraState.Inactive || state === CameraState.Error) {
                this.startCamera(entity);
            }
        }
    }
    /**
     * Start camera stream for an entity
     * Async operation - sets state to Starting, then Active when complete
     * Users should check state or null-check texture/videoElement before using
     *
     * Checks state after each async operation to abort if stopCamera was called
     */
    async startCamera(entity) {
        // Set state to Starting to prevent duplicate attempts
        entity.setValue(CameraSource, 'state', CameraState.Starting);
        try {
            let deviceId = entity.getValue(CameraSource, 'deviceId');
            // Auto-select camera if no deviceId provided
            if (!deviceId) {
                const devices = await CameraUtils.getDevices();
                // Check if we should abort (stopCamera was called during async operation)
                const currentState = entity.getValue(CameraSource, 'state');
                if (currentState !== CameraState.Starting) {
                    return; // Aborted
                }
                const facing = entity.getValue(CameraSource, 'facing');
                if (facing === CameraFacing.Unknown) {
                    // Unknown = any camera is fine, use first available
                    if (devices.length > 0) {
                        deviceId = devices[0].deviceId;
                        entity.setValue(CameraSource, 'deviceId', deviceId);
                    }
                    else {
                        console.error('No cameras available');
                        entity.setValue(CameraSource, 'state', CameraState.Error);
                        return;
                    }
                }
                else {
                    // Specific facing requested - must match or fail
                    const selected = CameraUtils.findByFacing(devices, facing);
                    if (selected) {
                        deviceId = selected.deviceId;
                        entity.setValue(CameraSource, 'deviceId', deviceId);
                    }
                    else {
                        const facingStr = facing === CameraFacing.Back ? 'back' : 'front';
                        console.error(`No ${facingStr}-facing camera available (found ${devices.length} camera(s))`);
                        entity.setValue(CameraSource, 'state', CameraState.Error);
                        return;
                    }
                }
            }
            // Get stream constraints
            const width = entity.getValue(CameraSource, 'width');
            const height = entity.getValue(CameraSource, 'height');
            const frameRate = entity.getValue(CameraSource, 'frameRate');
            // Request camera stream
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    deviceId: { exact: deviceId },
                    width: { ideal: width },
                    height: { ideal: height },
                    frameRate: { ideal: frameRate },
                },
            });
            // Check if we should abort after getting stream
            const currentState = entity.getValue(CameraSource, 'state');
            if (currentState !== CameraState.Starting) {
                // Aborted - clean up the stream we just created
                this.cleanupCameraResources(stream, null, null);
                return;
            }
            // Create video element
            const video = document.createElement('video');
            video.setAttribute('playsinline', '');
            video.setAttribute('autoplay', '');
            video.muted = true;
            video.srcObject = stream;
            // Wait for video to be ready
            await new Promise((resolve, reject) => {
                const onCanPlay = () => {
                    video.removeEventListener('canplay', onCanPlay);
                    video.removeEventListener('error', onError);
                    resolve();
                };
                const onError = (error) => {
                    video.removeEventListener('canplay', onCanPlay);
                    video.removeEventListener('error', onError);
                    reject(error);
                };
                video.addEventListener('canplay', onCanPlay);
                video.addEventListener('error', onError);
            });
            // Check if we should abort after video ready
            const finalState = entity.getValue(CameraSource, 'state');
            if (finalState !== CameraState.Starting) {
                // Aborted - clean up everything
                this.cleanupCameraResources(stream, video, null);
                return;
            }
            // Start playback
            await video.play();
            // Create VideoTexture
            const texture = new VideoTexture(video);
            texture.minFilter = LinearFilter;
            texture.magFilter = LinearFilter;
            // Final check before committing - ensure state is still Starting
            const committingState = entity.getValue(CameraSource, 'state');
            if (committingState !== CameraState.Starting) {
                // Aborted at the last moment - clean up everything
                this.cleanupCameraResources(stream, video, texture);
                return;
            }
            // Commit all resources atomically
            entity.setValue(CameraSource, 'stream', stream);
            entity.setValue(CameraSource, 'videoElement', video);
            entity.setValue(CameraSource, 'texture', texture);
            entity.setValue(CameraSource, 'state', CameraState.Active);
        }
        catch (error) {
            console.error('Failed to start camera:', error);
            // Clean up any partial state
            const stream = entity.getValue(CameraSource, 'stream');
            const video = entity.getValue(CameraSource, 'videoElement');
            const texture = entity.getValue(CameraSource, 'texture');
            this.cleanupCameraResources(stream, video, texture);
            entity.setValue(CameraSource, 'stream', null);
            entity.setValue(CameraSource, 'videoElement', null);
            entity.setValue(CameraSource, 'texture', null);
            entity.setValue(CameraSource, 'state', CameraState.Error);
        }
    }
    /**
     * Stop camera stream for an entity
     */
    stopCamera(entity) {
        const stream = entity.getValue(CameraSource, 'stream');
        const video = entity.getValue(CameraSource, 'videoElement');
        const texture = entity.getValue(CameraSource, 'texture');
        this.cleanupCameraResources(stream, video, texture);
        // Clear component values and set state to Inactive
        entity.setValue(CameraSource, 'stream', null);
        entity.setValue(CameraSource, 'videoElement', null);
        entity.setValue(CameraSource, 'texture', null);
        entity.setValue(CameraSource, 'state', CameraState.Inactive);
    }
    /**
     * Clean up camera resources (stream, video element, texture)
     */
    cleanupCameraResources(stream, video, texture) {
        if (stream) {
            stream.getTracks().forEach((track) => track.stop());
        }
        if (video) {
            video.pause();
            video.srcObject = null;
        }
        if (texture) {
            texture.dispose();
        }
    }
}

export { CameraSystem };
//# sourceMappingURL=camera-system.js.map
