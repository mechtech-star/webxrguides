import { PhysicsBody, DEFAULT_LINEAR_DAMPING, DEFAULT_ANGULAR_DAMPING, DEFAULT_GRAVITY_FACTOR, PhysicsState } from './physicsBody.js';
import { PhysicsShape, PhysicsShapeType } from './physicsShape.js';
import '../index.js';
import '../runtime/three.js';
import { detectShapeFromGeometry, generateMergedGeometry } from './utils.js';
import { PhysicsManipulation } from './physicsManipulation.js';
import { Types, ne } from 'elics';
import { Pressed } from '../input/state-tags.js';
import '../grab/index.js';
import { createSystem } from '../ecs/system.js';
import { Vector3, Matrix4, Mesh } from 'three';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Manages physics simulation using the Havok physics engine.
 *
 * @remarks
 * - Initializes Havok physics engine and creates a physics world with gravity.
 * - Supports automatic physics shapes creation based on entity geometry when {@link PhysicsShapeType.Auto} is used.
 * - Supports multiple collision shapes: Sphere, Box, Cylinder, ConvexHull, and TriMesh.
 * - Synchronizes physics body transforms with Three.js Object3D positions and rotations using {@link PhysicsBody}.
 * - Handles physics manipulations like applying forces and setting velocities in {@link PhysicsManipulation}.
 * - Automatically cleans up physics resources when entities are removed.
 *
 * @example Basic physics setup
 * ```ts
 * // Add to your world to enable physics
 * world.addSystem(PhysicsSystem)
 *
 * // Create a dynamic box that falls due to gravity
 * const box = world.createTransformEntity(boxMesh)
 * box.addComponent(PhysicsShape, {
 *   shape: PhysicsShapeType.Box,
 *   dimensions: [1, 1, 1]
 * })
 * box.addComponent(PhysicsBody, { state: PhysicsState.Dynamic })
 * ```
 *
 * @category Physics
 * @see {@link PhysicsBody}
 * @see {@link PhysicsShape}
 * @see {@link PhysicsManipulation}
 */
class PhysicsSystem extends createSystem({
    physicsEntities: {
        required: [PhysicsBody, PhysicsShape],
    },
    manipluatedEntities: {
        required: [PhysicsBody, PhysicsManipulation],
        where: [ne(PhysicsBody, '_engineBody', 0)],
    },
}, {
    gravity: { type: Types.Vec3, default: [0, -9.81, 0] },
}) {
    constructor() {
        super(...arguments);
        this.scaleBuffer = new Vector3();
        this.matrixBuffer = new Matrix4();
    }
    async init() {
        const { default: HavokPhysics } = await import('@babylonjs/havok');
        this.havok = await HavokPhysics();
        this.havokWorld = this.havok.HP_World_Create()[1];
        this.havok.HP_World_SetGravity(this.havokWorld, this.config.gravity.value);
        // Unified cleanup
        this.queries.physicsEntities.subscribe('disqualify', (entity) => {
            if (!this.havok || !this.havokWorld) {
                return;
            }
            const engineShape = entity.getValue(PhysicsShape, '_engineShape');
            if (engineShape) {
                this.havok.HP_Shape_Release([BigInt(engineShape)]);
            }
            const engineBody = entity.getValue(PhysicsBody, '_engineBody');
            if (engineBody) {
                this.havok.HP_World_RemoveBody(this.havokWorld, [BigInt(engineBody)]);
            }
        });
    }
    update(delta) {
        if (this.havok && this.havokWorld) {
            this.havok.HP_World_SetIdealStepTime(this.havokWorld, delta);
            this.havok.HP_World_Step(this.havokWorld, delta);
            this.bodyBuffer = this.havok.HP_World_GetBodyBuffer(this.havokWorld)[1];
        }
        this.queries.physicsEntities.entities.forEach((entity) => {
            var _a, _b, _c, _d;
            if (!entity.object3D || !this.havok || !this.havokWorld) {
                return;
            }
            const engineShape = entity.getValue(PhysicsShape, '_engineShape');
            const engineBody = entity.getValue(PhysicsBody, '_engineBody');
            if (!engineShape) {
                const dimensionsView = entity.getVectorView(PhysicsShape, 'dimensions');
                this.createHavokShapes(entity, dimensionsView);
                return;
            }
            else {
                if (!engineBody && engineShape) {
                    const bodyRepsonse = this.createBody([BigInt(engineShape)], entity.object3D.position, entity.object3D.quaternion, entity.getValue(PhysicsBody, 'state'), (_a = entity.getValue(PhysicsBody, 'linearDamping')) !== null && _a !== void 0 ? _a : DEFAULT_LINEAR_DAMPING, (_b = entity.getValue(PhysicsBody, 'angularDamping')) !== null && _b !== void 0 ? _b : DEFAULT_ANGULAR_DAMPING, (_c = entity.getValue(PhysicsBody, 'gravityFactor')) !== null && _c !== void 0 ? _c : DEFAULT_GRAVITY_FACTOR, entity.getVectorView(PhysicsBody, 'centerOfMass'));
                    if (bodyRepsonse) {
                        entity.setValue(PhysicsBody, '_engineBody', Number(bodyRepsonse.createdBody));
                        entity.setValue(PhysicsBody, '_engineOffset', bodyRepsonse.offset);
                    }
                }
                else if (engineBody && this.bodyBuffer) {
                    const linearVelocity = this.havok.HP_Body_GetLinearVelocity([
                        BigInt(engineBody),
                    ]);
                    const angularVelocity = this.havok.HP_Body_GetAngularVelocity([
                        BigInt(engineBody),
                    ]);
                    const linearVelocityView = entity.getVectorView(PhysicsBody, '_linearVelocity');
                    const angularVelocityView = entity.getVectorView(PhysicsBody, '_angularVelocity');
                    linearVelocityView.set(linearVelocity[1]);
                    angularVelocityView.set(angularVelocity[1]);
                    // Processing physics body motion here
                    const position = entity.object3D.position;
                    const quaternion = entity.object3D.quaternion;
                    if (entity.hasComponent(Pressed)) {
                        this.havok.HP_Body_SetTargetQTransform([BigInt(engineBody)], [
                            [position.x, position.y, position.z],
                            [quaternion.x, quaternion.y, quaternion.z, quaternion.w],
                        ]);
                        return;
                    }
                    const bodyOffset = (_d = entity.getValue(PhysicsBody, '_engineOffset')) !== null && _d !== void 0 ? _d : 0;
                    const transformBuffer = new Float32Array(this.havok.HEAPU8.buffer, this.bodyBuffer + bodyOffset, 16);
                    for (let mi = 0; mi < 15; mi++) {
                        if ((mi & 3) != 3) {
                            this.matrixBuffer.elements[mi] = transformBuffer[mi];
                        }
                    }
                    this.matrixBuffer.elements[15] = 1.0;
                    this.matrixBuffer.decompose(position, quaternion, this.scaleBuffer);
                }
            }
        });
        this.queries.manipluatedEntities.entities.forEach((entity) => {
            const engineBody = entity.getValue(PhysicsBody, '_engineBody');
            if (!entity.object3D || !this.havok || !this.havokWorld || !engineBody) {
                return;
            }
            // Applying one time force to the body
            if (!entity
                .getVectorView(PhysicsManipulation, 'force')
                .every((element) => element === 0)) {
                const force = entity.getVectorView(PhysicsManipulation, 'force');
                this.havok.HP_Body_ApplyImpulse([BigInt(engineBody)], [
                    entity.object3D.position.x,
                    entity.object3D.position.y,
                    entity.object3D.position.z,
                ], [force[0] * delta, force[1] * delta, force[2] * delta]);
            }
            // Applying one time linear velocity to the body
            if (!entity
                .getVectorView(PhysicsManipulation, 'linearVelocity')
                .every((element) => element === 0)) {
                const linearVelocity = entity.getVectorView(PhysicsManipulation, 'linearVelocity');
                this.havok.HP_Body_SetLinearVelocity([BigInt(engineBody)], [linearVelocity[0], linearVelocity[1], linearVelocity[2]]);
            }
            // Applying one time angular velocity to the body
            if (!entity
                .getVectorView(PhysicsManipulation, 'angularVelocity')
                .every((element) => element === 0)) {
                const angularVelocity = entity.getVectorView(PhysicsManipulation, 'angularVelocity');
                this.havok.HP_Body_SetAngularVelocity([BigInt(engineBody)], [angularVelocity[0], angularVelocity[1], angularVelocity[2]]);
            }
            entity.removeComponent(PhysicsManipulation);
        });
    }
    createBody(shape, position, quaternion, state, linearDamping, angularDamping, gravityFactor, centerOfMass) {
        if (!this.havok || !this.havokWorld) {
            return;
        }
        const body = this.havok.HP_Body_Create()[1];
        this.havok.HP_Body_SetShape(body, shape);
        this.havok.HP_Body_SetQTransform(body, [
            [position.x, position.y, position.z],
            [quaternion.x, quaternion.y, quaternion.z, quaternion.w],
        ]);
        this.havok.HP_Body_SetLinearDamping(body, linearDamping);
        this.havok.HP_Body_SetAngularDamping(body, angularDamping);
        this.havok.HP_Body_SetGravityFactor(body, gravityFactor);
        const shapeMass = this.havok.HP_Shape_BuildMassProperties(shape);
        const massProps = shapeMass[0] == this.havok.Result.RESULT_OK
            ? shapeMass[1]
            : [[0, 0, 0], 1, [1, 1, 1], [0, 0, 0, 1]];
        if (!centerOfMass.every((e) => e == Infinity)) {
            massProps[0] = [centerOfMass[0], centerOfMass[1], centerOfMass[2]];
        }
        this.havok.HP_Body_SetMassProperties(body, massProps);
        let motionType;
        switch (state) {
            case PhysicsState.Static:
                motionType = this.havok.MotionType.STATIC;
                break;
            case PhysicsState.Kinematic:
                motionType = this.havok.MotionType.KINEMATIC;
                break;
            case PhysicsState.Dynamic:
            default:
                motionType = this.havok.MotionType.DYNAMIC;
        }
        this.havok.HP_Body_SetMotionType(body, motionType);
        this.havok.HP_World_AddBody(this.havokWorld, body, false);
        return {
            offset: this.havok.HP_Body_GetWorldTransformOffset(body)[1],
            createdBody: body,
        };
    }
    createHavokShapes(entity, dimensionsView) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        if (!entity.object3D) {
            console.warn('PhysicsSystem: No object3D attached to entity', entity.index);
            return;
        }
        // Determine the actual shape type (resolve Auto if needed)
        let shapeType = entity.getValue(PhysicsShape, 'shape');
        if (shapeType === PhysicsShapeType.Auto) {
            const detection = detectShapeFromGeometry(entity.object3D);
            // Update the entity's shape type and dimensions if they were auto-detected
            entity.setValue(PhysicsShape, 'shape', detection.shapeType);
            shapeType = detection.shapeType;
            if (detection.dimensions) {
                // Re-read the updated dimensions view
                dimensionsView.set(detection.dimensions);
            }
        }
        switch (shapeType) {
            case PhysicsShapeType.Sphere: {
                const ballShape = this.createBallShape(dimensionsView[0], (_a = entity.getValue(PhysicsShape, 'density')) !== null && _a !== void 0 ? _a : 1.0, (_b = entity.getValue(PhysicsShape, 'restitution')) !== null && _b !== void 0 ? _b : 0, (_c = entity.getValue(PhysicsShape, 'friction')) !== null && _c !== void 0 ? _c : 0.5);
                if (ballShape) {
                    PhysicsShape.data._engineShape[entity.index] = Number(ballShape);
                }
                else {
                    console.warn('PhysicsSystem: Failed to create ball shape for entity', entity.index);
                }
                break;
            }
            case PhysicsShapeType.Box: {
                const boxShape = this.createBoxShape(dimensionsView, (_d = entity.getValue(PhysicsShape, 'density')) !== null && _d !== void 0 ? _d : 1.0, (_e = entity.getValue(PhysicsShape, 'restitution')) !== null && _e !== void 0 ? _e : 0, (_f = entity.getValue(PhysicsShape, 'friction')) !== null && _f !== void 0 ? _f : 0.5);
                if (boxShape) {
                    PhysicsShape.data._engineShape[entity.index] = Number(boxShape);
                }
                else {
                    console.warn('PhysicsSystem: Failed to create box shape for entity', entity.index);
                }
                break;
            }
            case PhysicsShapeType.Cylinder: {
                const cylinderShape = this.createCylinderShape(dimensionsView[0], // radius
                dimensionsView[1], // height
                (_g = entity.getValue(PhysicsShape, 'density')) !== null && _g !== void 0 ? _g : 1.0, (_h = entity.getValue(PhysicsShape, 'restitution')) !== null && _h !== void 0 ? _h : 0, (_j = entity.getValue(PhysicsShape, 'friction')) !== null && _j !== void 0 ? _j : 0.5);
                if (cylinderShape) {
                    PhysicsShape.data._engineShape[entity.index] = Number(cylinderShape);
                }
                else {
                    console.warn('PhysicsSystem: Failed to create cylinder shape for entity', entity.index);
                }
                break;
            }
            case PhysicsShapeType.ConvexHull: {
                const convexHullShape = this.createConvexHullShape(entity.object3D, (_k = entity.getValue(PhysicsShape, 'density')) !== null && _k !== void 0 ? _k : 1.0, (_l = entity.getValue(PhysicsShape, 'restitution')) !== null && _l !== void 0 ? _l : 0, (_m = entity.getValue(PhysicsShape, 'friction')) !== null && _m !== void 0 ? _m : 0.5);
                if (convexHullShape) {
                    PhysicsShape.data._engineShape[entity.index] =
                        Number(convexHullShape);
                }
                else {
                    console.warn('PhysicsSystem: Failed to create convex hull shape for entity', entity.index);
                }
                break;
            }
            case PhysicsShapeType.TriMesh: {
                const triMeshShape = this.createTriMeshShape(entity.object3D, (_o = entity.getValue(PhysicsShape, 'density')) !== null && _o !== void 0 ? _o : 1.0, (_p = entity.getValue(PhysicsShape, 'restitution')) !== null && _p !== void 0 ? _p : 0, (_q = entity.getValue(PhysicsShape, 'friction')) !== null && _q !== void 0 ? _q : 0.5);
                if (triMeshShape) {
                    PhysicsShape.data._engineShape[entity.index] = Number(triMeshShape);
                }
                else {
                    console.warn('PhysicsSystem: Failed to create tri-mesh shape for entity', entity.index);
                }
                break;
            }
        }
    }
    createBallShape(radius, density, restitution, friction) {
        if (!this.havok) {
            console.warn('PhysicsSystem: Cannot create ball shape - Havok physics engine not initialized');
            return;
        }
        const ballShape = this.havok.HP_Shape_CreateSphere([0, 0, 0], radius)[1];
        this.havok.HP_Shape_SetDensity(ballShape, density);
        this.havok.HP_Shape_SetMaterial(ballShape, [
            friction,
            friction,
            restitution,
            this.havok.MaterialCombine.MINIMUM,
            this.havok.MaterialCombine.MAXIMUM,
        ]);
        return ballShape;
    }
    createBoxShape(scale, density, restitution, friction) {
        if (!this.havok) {
            console.warn('PhysicsSystem: Cannot create box shape - Havok physics engine not initialized');
            return;
        }
        const boxShape = this.havok.HP_Shape_CreateBox([0, 0, 0], [0, 0, 0, 1], [scale[0], scale[1], scale[2]])[1];
        this.havok.HP_Shape_SetDensity(boxShape, density);
        this.havok.HP_Shape_SetMaterial(boxShape, [
            friction,
            friction,
            restitution,
            this.havok.MaterialCombine.MINIMUM,
            this.havok.MaterialCombine.MAXIMUM,
        ]);
        return boxShape;
    }
    createCylinderShape(radius, height, density, restitution, friction) {
        if (!this.havok) {
            console.warn('PhysicsSystem: Cannot create cylinder shape - Havok physics engine not initialized');
            return;
        }
        const cylinderShape = this.havok.HP_Shape_CreateCylinder([0, 0, 0], [0, height, 0], radius)[1];
        this.havok.HP_Shape_SetDensity(cylinderShape, density);
        this.havok.HP_Shape_SetMaterial(cylinderShape, [
            friction,
            friction,
            restitution,
            this.havok.MaterialCombine.MINIMUM,
            this.havok.MaterialCombine.MAXIMUM,
        ]);
        return cylinderShape;
    }
    createConvexHullShape(object3D, density, restitution, friction) {
        if (!this.havok) {
            console.warn('PhysicsSystem: Cannot create convex hull shape - Havok physics engine not initialized');
            return;
        }
        const geometry = object3D instanceof Mesh
            ? object3D.geometry
            : generateMergedGeometry(object3D);
        const vertices = this.getVertices(geometry.attributes.position.array);
        if (!vertices) {
            console.warn('PhysicsSystem: Failed to get vertices for convex hull shape with object3D name ' +
                object3D.name +
                ' &id ' +
                object3D.id);
            return;
        }
        const convexHullShape = this.havok.HP_Shape_CreateConvexHull(vertices.offset, vertices.numObjects / 3)[1];
        this.havok._free(vertices.offset);
        this.havok.HP_Shape_SetDensity(convexHullShape, density);
        this.havok.HP_Shape_SetMaterial(convexHullShape, [
            friction,
            friction,
            restitution,
            this.havok.MaterialCombine.MINIMUM,
            this.havok.MaterialCombine.MAXIMUM,
        ]);
        return convexHullShape;
    }
    createTriMeshShape(object3D, density, restitution, friction) {
        if (!this.havok) {
            console.warn('PhysicsSystem: Cannot create tri-mesh shape - Havok physics engine not initialized');
            return;
        }
        const geometry = object3D instanceof Mesh
            ? object3D.geometry
            : generateMergedGeometry(object3D);
        const vertices = this.getVertices(geometry.attributes.position.array);
        const indices = this.getIndices(geometry.index.array);
        if (!vertices || !indices) {
            if (!vertices) {
                console.warn('PhysicsSystem: Failed to get vertices for tri-mesh shape with object3D name ' +
                    object3D.name +
                    ' &id ' +
                    object3D.id);
            }
            if (!indices) {
                console.warn('PhysicsSystem: Failed to get indices for tri-mesh shape with object3D name ' +
                    object3D.name +
                    ' &id ' +
                    object3D.id);
            }
            return;
        }
        const triMeshShape = this.havok.HP_Shape_CreateMesh(vertices.offset, vertices.numObjects / 3, indices.offset, indices.numObjects / 3)[1];
        this.havok._free(vertices.offset);
        this.havok._free(indices.offset);
        this.havok.HP_Shape_SetDensity(triMeshShape, density);
        this.havok.HP_Shape_SetMaterial(triMeshShape, [
            friction,
            friction,
            restitution,
            this.havok.MaterialCombine.MINIMUM,
            this.havok.MaterialCombine.MAXIMUM,
        ]);
        return triMeshShape;
    }
    getVertices(vertices) {
        const bytesPerFloat = 4;
        const nBytes = vertices.length * bytesPerFloat;
        const bufferBegin = this.havok._malloc(nBytes);
        const ret = new Float32Array(this.havok.HEAPU8.buffer, bufferBegin, vertices.length);
        for (let i = 0; i < vertices.length; i++) {
            ret[i] = vertices[i];
        }
        return { offset: bufferBegin, numObjects: vertices.length };
    }
    getIndices(indices) {
        const bytesPerInt = 4;
        const nBytes = indices.length * bytesPerInt;
        const bufferBegin = this.havok._malloc(nBytes);
        const ret = new Int32Array(this.havok.HEAPU8.buffer, bufferBegin, indices.length);
        for (let i = 0; i < indices.length; i++) {
            ret[i] = indices[i];
        }
        return { offset: bufferBegin, numObjects: indices.length };
    }
}

export { PhysicsSystem };
//# sourceMappingURL=physics-system.js.map
