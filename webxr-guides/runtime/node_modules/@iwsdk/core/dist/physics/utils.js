import '../runtime/three.js';
import { PhysicsShapeType } from './physicsShape.js';
import { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { Vector3, Quaternion, Matrix4, Mesh, SphereGeometry, BoxGeometry, PlaneGeometry, CylinderGeometry, BufferGeometry, Box3 } from 'three';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const tempVec1 = new Vector3();
const tempVec2 = new Vector3();
const tempQuat = new Quaternion();
const tempMatrix = new Matrix4();
const tempMatrix2 = new Matrix4();
const UNIT_SCALE = new Vector3(1, 1, 1);
/**
 * Automatically detects the best physics shape type and calculates dimensions based on the entity's Three.js geometry
 */
function detectShapeFromGeometry(object3D) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const geometry = object3D instanceof Mesh
        ? object3D.geometry
        : generateMergedGeometry(object3D);
    // Check for specific geometry types and calculate their dimensions
    if (geometry instanceof SphereGeometry) {
        const radius = (_a = geometry.parameters.radius) !== null && _a !== void 0 ? _a : 1;
        return {
            shapeType: PhysicsShapeType.Sphere,
            dimensions: [radius, 0, 0], // Only radius is needed for sphere
        };
    }
    if (geometry instanceof BoxGeometry) {
        const width = (_b = geometry.parameters.width) !== null && _b !== void 0 ? _b : 1;
        const height = (_c = geometry.parameters.height) !== null && _c !== void 0 ? _c : 1;
        const depth = (_d = geometry.parameters.depth) !== null && _d !== void 0 ? _d : 1;
        return {
            shapeType: PhysicsShapeType.Box,
            dimensions: [width, height, depth],
        };
    }
    if (geometry instanceof PlaneGeometry) {
        const width = (_e = geometry.parameters.width) !== null && _e !== void 0 ? _e : 1;
        const height = (_f = geometry.parameters.height) !== null && _f !== void 0 ? _f : 1;
        const thickness = 0.01; // Thin plane
        return {
            shapeType: PhysicsShapeType.Box,
            dimensions: [width, height, thickness],
        };
    }
    if (geometry instanceof CylinderGeometry) {
        const radiusTop = (_g = geometry.parameters.radiusTop) !== null && _g !== void 0 ? _g : 1;
        const radiusBottom = (_h = geometry.parameters.radiusBottom) !== null && _h !== void 0 ? _h : 1;
        if (radiusTop !== radiusBottom) {
            console.warn('PhysicsSystem: detected cylinder with different radiusTop and radiusBottom. Using average radius for the physics shape.');
        }
        const height = (_j = geometry.parameters.height) !== null && _j !== void 0 ? _j : 1;
        const avgRadius = (radiusTop + radiusBottom) / 2;
        return {
            shapeType: PhysicsShapeType.Cylinder,
            dimensions: [avgRadius, height, 0], // Approximate bounding dimensions
        };
    }
    // For generic BufferGeometry, fall back to the default ConvexHull shape type for better perf
    if (geometry instanceof BufferGeometry) {
        console.log(`PhysicsSystem: BufferGeometry detected for object ${object3D}, using ConvexHull.`);
        return {
            shapeType: PhysicsShapeType.ConvexHull,
            dimensions: null,
        };
    }
    // Fallback for unknown geometry types
    console.warn(`PhysicsSystem: Unknown geometry type for object ${object3D}, falling back to Box`);
    return {
        shapeType: PhysicsShapeType.Box,
        dimensions: calculateObject3DBounds(object3D),
    };
}
/**
 * Calculates bounding box dimensions from Object3D for fallback cases
 */
function calculateObject3DBounds(object3D) {
    try {
        // Create a bounding box for the object
        const box = new Box3().setFromObject(object3D);
        if (!box.isEmpty()) {
            const size = new Vector3();
            box.getSize(size);
            // Convert to half-extents and ensure minimum size
            const dimensions = [
                Math.max(size.x, 0.01),
                Math.max(size.y, 0.01),
                Math.max(size.z, 0.01),
            ];
            console.log(`PhysicsSystem: Calculated Object3D bounds: [${dimensions.join(', ')}]`);
            return dimensions;
        }
        else {
            console.warn('PhysicsSystem: Object3D bounding box is empty, using default dimensions');
        }
    }
    catch (error) {
        console.warn('PhysicsSystem: Failed to calculate Object3D bounds:', error);
    }
    // Final fallback if bounding box calculation fails
    return [1, 1, 1];
}
function generateMergedGeometry(object3D) {
    object3D.updateMatrixWorld(true);
    tempMatrix.copy(object3D.matrixWorld);
    tempMatrix.decompose(tempVec1, tempQuat, tempVec2);
    tempMatrix.compose(tempVec1, tempQuat, UNIT_SCALE);
    const geometries = [];
    object3D.traverse((child) => {
        if (child.isMesh && child.geometry) {
            const geometry = child.geometry.clone();
            geometry.applyMatrix4(child.matrixWorld);
            geometries.push(geometry);
        }
    });
    const mergedGeometry = mergeGeometries(geometries);
    tempMatrix2.copy(tempMatrix).invert();
    mergedGeometry.applyMatrix4(tempMatrix2);
    object3D.matrixWorld.copy(tempMatrix);
    return mergedGeometry;
}

export { calculateObject3DBounds, detectShapeFromGeometry, generateMergedGeometry };
//# sourceMappingURL=utils.js.map
