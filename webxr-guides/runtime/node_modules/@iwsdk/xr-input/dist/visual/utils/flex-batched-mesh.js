import { Group, Matrix4, BatchedMesh } from 'three';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class FlexBatchedMesh extends Group {
    constructor(refMesh) {
        super();
        this.refMesh = refMesh;
        this.batchedMeshes = new Map();
        this.batchedIndices = new Map();
        const meshes = [];
        refMesh.traverse((child) => {
            child.matrixAutoUpdate = false;
            const childMesh = child;
            if (childMesh.isMesh) {
                meshes.push(childMesh);
            }
            child.userData.batchedMatrix = new Matrix4();
        });
        // Group meshes by material
        const materialGroups = new Map();
        meshes.forEach((mesh) => {
            const material = mesh.material;
            if (!materialGroups.has(material)) {
                materialGroups.set(material, []);
            }
            materialGroups.get(material).push(mesh);
        });
        // Create a BatchedMesh for each material group
        materialGroups.forEach((meshes, material) => {
            let geometryCount = 0;
            let vertexCount = 0;
            let indexCount = 0;
            meshes.forEach((mesh) => {
                vertexCount += mesh.geometry.attributes.position.count;
                indexCount += mesh.geometry.index.count;
                geometryCount++;
            });
            const batchedMesh = new BatchedMesh(geometryCount, vertexCount, indexCount, material);
            this.batchedMeshes.set(material, batchedMesh);
            this.add(batchedMesh);
            meshes.forEach((mesh) => {
                const geometryId = batchedMesh.addGeometry(mesh.geometry);
                this.batchedIndices.set(mesh, batchedMesh.addInstance(geometryId));
            });
        });
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        // Calculate the batched matrices from the reference mesh
        this.refMesh.traverse((child) => {
            child.updateMatrix();
            if (child !== this.refMesh) {
                child.userData.batchedMatrix.multiplyMatrices(child.parent.userData.batchedMatrix, child.matrix);
            }
        });
        // Update each BatchedMesh with the new matrices
        this.batchedIndices.forEach((batchedIndex, mesh) => {
            const material = mesh.material;
            const batchedMesh = this.batchedMeshes.get(material);
            if (batchedMesh) {
                batchedMesh.setMatrixAt(batchedIndex, mesh.userData.batchedMatrix);
            }
        });
    }
}

export { FlexBatchedMesh };
//# sourceMappingURL=flex-batched-mesh.js.map
