import { DEFAULT_PROFILES_PATH } from '../../gamepad/input-profiles.js';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class XRInputVisualAdapter {
    constructor(playerSpace, handedness, visualsEnabled, visualClass, scene, camera, assetLoader) {
        this.playerSpace = playerSpace;
        this.handedness = handedness;
        this.visualsEnabled = visualsEnabled;
        this.visualClass = visualClass;
        this.scene = scene;
        this.camera = camera;
        this.assetLoader = assetLoader;
        this.isPrimary = false;
    }
    connectVisual() {
        if (this.inputConfig) {
            const { inputSource, layout } = this.inputConfig;
            XRInputVisualAdapter.createVisual(this.visualClass, inputSource, layout, this.visualsEnabled, this.scene, this.camera, this.assetLoader).then((visual) => {
                if (visual &&
                    inputSource === this._inputSource &&
                    visual.constructor === this.visualClass) {
                    this.visual = visual;
                    this.visual.xrInput = this;
                    this.playerSpace.add(visual.model);
                }
            });
        }
    }
    disconnectVisual() {
        if (this.visual) {
            this.visual.disconnect();
            this.visual.xrInput = undefined;
            this.visual.model.removeFromParent();
            this.visual = undefined;
        }
    }
    updateVisualImplementation(visualClass) {
        this.disconnectVisual();
        this.visualClass = visualClass;
        this.connectVisual();
    }
    get connected() {
        return !!this._inputSource;
    }
    // add hooks for connect and disconnect
    get inputSource() {
        return this._inputSource;
    }
    connect(inputSource) {
        if (this._inputSource) {
            this.disconnect();
        }
        this._inputSource = inputSource;
        // Provide fallback for runtimes that only surface gripSpace or targetRaySpace
    }
    disconnect() {
        this._inputSource = undefined;
    }
    get pointerBusy() {
        return false;
    }
    static async createVisual(visualClass, inputSource, layout, enabled, scene, camera, assetLoader) {
        var _a, _b;
        const profileId = (_a = visualClass.assetProfileId) !== null && _a !== void 0 ? _a : inputSource.profiles[0];
        const assetPath = (_b = visualClass.assetPath) !== null && _b !== void 0 ? _b : `${DEFAULT_PROFILES_PATH}/${profileId}/${inputSource.handedness}.glb`;
        const assetKeyPrefix = visualClass.assetKeyPrefix;
        const assetKey = `${assetKeyPrefix}-${profileId}-${inputSource.handedness}`;
        let visual;
        if (this.visualCache.has(assetKey)) {
            visual = this.visualCache.get(assetKey);
        }
        else {
            const gltf = await assetLoader.loadGLTF(assetPath);
            visual = new visualClass(scene, camera, gltf.scene, layout);
            visual.init();
            this.visualCache.set(assetKey, visual);
        }
        visual.connect(inputSource, enabled);
        return visual;
    }
}
XRInputVisualAdapter.cursorPool = [];
XRInputVisualAdapter.visualCache = new Map();

export { XRInputVisualAdapter };
//# sourceMappingURL=base-visual-adapter.js.map
