import { Vector3, Matrix4 } from 'three';
import { XRInputVisualAdapter } from './base-visual-adapter.js';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const PINCH_COOLDOWN = 0.2;
const defaultHandLayout = {
    selectComponentId: 'pinch',
    components: {
        pinch: {
            type: 'button',
            gamepadIndices: {
                button: 0,
            },
            rootNodeName: '',
            visualResponses: {},
        },
        swipeleft: {
            type: 'button',
            gamepadIndices: {
                button: 5,
            },
            rootNodeName: '',
            visualResponses: {},
        },
        swiperight: {
            type: 'button',
            gamepadIndices: {
                button: 6,
            },
            rootNodeName: '',
            visualResponses: {},
        },
        swipeup: {
            type: 'button',
            gamepadIndices: {
                button: 7,
            },
            rootNodeName: '',
            visualResponses: {},
        },
        swipedown: {
            type: 'button',
            gamepadIndices: {
                button: 8,
            },
            rootNodeName: '',
            visualResponses: {},
        },
        confirm: {
            type: 'button',
            gamepadIndices: {
                button: 9,
            },
            rootNodeName: '',
            visualResponses: {},
        },
    },
    rootNodeName: '',
    gamepadMapping: 'xr-standard',
    assetPath: '',
};
class XRHandVisualAdapter extends XRInputVisualAdapter {
    constructor(playerSpace, handedness, visualsEnabled, visualClass, scene, camera, assetLoader) {
        super(playerSpace, handedness, visualsEnabled, visualClass, scene, camera, assetLoader);
        this.jointSpaces = [];
        this.pinchThreshold = 0.008;
        this.pinchCooldown = 0;
        this.pinchData = { prev: false, curr: false };
        this.vec3 = new Vector3();
        this.mat4 = new Matrix4();
    }
    connect(inputSource) {
        super.connect(inputSource);
        const hand = inputSource.hand;
        this.gripXRSpace = inputSource.gripSpace || inputSource.targetRaySpace;
        hand.forEach((jointSpace) => {
            if (jointSpace.jointName === 'index-finger-tip') {
                this.indexTip = jointSpace;
            }
            else if (jointSpace.jointName === 'thumb-tip') {
                this.thumbTip = jointSpace;
            }
            this.jointSpaces.push(jointSpace);
        });
        this.jointTransforms = new Float32Array(hand.size * 16);
        this.inputConfig = {
            inputSource,
            layout: defaultHandLayout,
        };
        this.connectVisual();
    }
    disconnect() {
        super.disconnect();
        this.jointTransforms = undefined;
        this.jointSpaces.length = 0;
        this.indexTip = undefined;
        this.thumbTip = undefined;
        this.disconnectVisual();
    }
    update(frame, delta) {
        var _a, _b, _c, _d;
        if (this._inputSource && this.jointTransforms) {
            const success = (_b = (_a = frame.fillPoses) === null || _a === void 0 ? void 0 : _a.call(frame, this.jointSpaces, this.gripXRSpace, this.jointTransforms)) !== null && _b !== void 0 ? _b : false;
            if (success) {
                this.updatePinch(frame, delta);
                if (this.visual && this.gripSpace) {
                    this.visual.model.position.copy(this.gripSpace.position);
                    this.visual.model.quaternion.copy(this.gripSpace.quaternion);
                    this.visual.update(delta);
                }
                if (this.pendingCapture) {
                    const { refSpace, resolve, reject } = this.pendingCapture;
                    const jointTransforms = new Float32Array(this.jointTransforms.length);
                    const success = (_d = (_c = frame.fillPoses) === null || _c === void 0 ? void 0 : _c.call(frame, this.jointSpaces, refSpace, jointTransforms)) !== null && _d !== void 0 ? _d : false;
                    if (success) {
                        const pose = {};
                        this.jointSpaces.forEach((jointSpace, index) => {
                            pose[jointSpace.jointName] = this.mat4
                                .fromArray(jointTransforms, index * 16)
                                .toArray();
                        });
                        resolve(pose);
                    }
                    else {
                        reject();
                    }
                    this.pendingCapture = undefined;
                }
            }
        }
    }
    updatePinch(frame, delta) {
        this.pinchData.prev = this.pinchData.curr;
        if (this.pinchCooldown > 0) {
            this.pinchData.curr = true;
            this.pinchCooldown -= delta;
            return;
        }
        if (this.indexTip && this.thumbTip) {
            const pose = frame.getPose(this.indexTip, this.thumbTip);
            if (pose) {
                this.vec3.copy(pose.transform.position);
                const pinching = this.vec3.length() < this.pinchThreshold;
                if (pinching) {
                    this.pinchCooldown = PINCH_COOLDOWN;
                }
                this.pinchData.curr = pinching;
            }
        }
    }
    toggleVisual(enabled) {
        this.visualsEnabled = enabled;
        if (this.visual) {
            this.visual.toggle(enabled);
        }
    }
    // getSelectStart() {
    // 	return this.pinchData.curr && !this.pinchData.prev;
    // }
    // getSelectEnd() {
    // 	return !this.pinchData.curr && this.pinchData.prev;
    // }
    // getSelecting() {
    // 	return this.pinchData.curr;
    // }
    capturePose(refSpace) {
        return new Promise((resolve, reject) => {
            this.pendingCapture = {
                refSpace,
                resolve,
                reject,
            };
        });
    }
}

export { XRHandVisualAdapter, defaultHandLayout };
//# sourceMappingURL=hand-visual-adapter.js.map
