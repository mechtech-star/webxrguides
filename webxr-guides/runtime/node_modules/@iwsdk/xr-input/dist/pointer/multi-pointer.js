import { CombinedPointer } from '@pmndrs/pointer-events';
import { GrabPointer } from './grab-pointer.js';
import { RayPointer } from './ray-pointer.js';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class MultiPointer {
    constructor(handedness, scene, camera, xrOrigin) {
        this.handedness = handedness;
        this.scene = scene;
        this.camera = camera;
        this.xrOrigin = xrOrigin;
        this.registered = [];
        this.defaultKind = 'ray';
        this.combined = new CombinedPointer(false);
        // Build built-ins (register only ray by default)
        const ray = new RayPointer(this.camera, this.xrOrigin, this.handedness);
        const grab = new GrabPointer(this.camera, this.xrOrigin, this.handedness);
        this.ray = { pointer: ray.pointer, visual: ray, registered: false };
        this.grab = { pointer: grab.pointer, visual: grab, registered: false };
        this.toggleSubPointer('ray', true);
    }
    update(connected, delta, time, input) {
        var _a, _b;
        const timeStamp = time * 1000;
        this.combined.setEnabled(connected, { timeStamp });
        this.combined.move(this.scene, { timeStamp });
        // Visuals policy for ray
        const policy = this.getPolicyForRay();
        (_a = this.ray) === null || _a === void 0 ? void 0 : _a.visual.update(connected, delta, time, !!(input === null || input === void 0 ? void 0 : input.selectStart), !!(input === null || input === void 0 ? void 0 : input.selectEnd), policy);
        // Emit down/up based on input
        if ((_b = this.grab) === null || _b === void 0 ? void 0 : _b.registered) {
            if (input === null || input === void 0 ? void 0 : input.squeezeStart) {
                this.routeDown('squeeze', 'grab', { timeStamp });
            }
            if (input === null || input === void 0 ? void 0 : input.squeezeEnd) {
                this.routeUp('squeeze', 'grab', { timeStamp });
            }
        }
        if (input === null || input === void 0 ? void 0 : input.selectStart) {
            this.routeDown('select', 'ray', { timeStamp });
        }
        if (input === null || input === void 0 ? void 0 : input.selectEnd) {
            this.routeUp('select', 'ray', { timeStamp });
        }
    }
    getPolicyForRay() {
        var _a, _b, _c;
        const rayCaptured = !!((_c = (_a = this.ray) === null || _a === void 0 ? void 0 : (_b = _a.pointer).getPointerCapture) === null || _c === void 0 ? void 0 : _c.call(_b));
        const nonRayCaptured = this.registered.some((r) => { var _a, _b; return r.kind !== 'ray' && !!((_b = (_a = r.pointer).getPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a)); });
        // Policy
        // - if ray captured → show ray, hide cursor
        // - else if other captured → hide both
        // - else → show both as usual
        return {
            forceHideRay: nonRayCaptured && !rayCaptured,
            forceHideCursor: rayCaptured || nonRayCaptured,
        };
    }
    getRayBusy() {
        var _a;
        return !!((_a = this.ray) === null || _a === void 0 ? void 0 : _a.visual.busy);
    }
    routeDown(kind, target, nativeEvent) {
        const ptr = this.pickTarget(target);
        if (!ptr) {
            return;
        }
        const button = kind === 'select' ? 0 : 2;
        ptr.down({ button, timeStamp: nativeEvent.timeStamp });
    }
    routeUp(kind, target, nativeEvent) {
        const ptr = this.pickTarget(target);
        if (!ptr) {
            return;
        }
        const button = kind === 'select' ? 0 : 2;
        ptr.up({ button, timeStamp: nativeEvent.timeStamp });
    }
    pickTarget(target) {
        var _a, _b, _c, _d, _e;
        if (target === 'active') {
            // Prefer captured pointer if any, else fall back to ray
            const captured = this.registered.find((r) => { var _a, _b; return !!((_b = (_a = r.pointer).getPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a)); });
            if (captured) {
                return captured.pointer;
            }
            return (_a = this.ray) === null || _a === void 0 ? void 0 : _a.pointer;
        }
        if (target === 'ray') {
            return (_b = this.ray) === null || _b === void 0 ? void 0 : _b.pointer;
        }
        return ((_d = (_c = this.grab) === null || _c === void 0 ? void 0 : _c.pointer) !== null && _d !== void 0 ? _d : (_e = this.registered.find((r) => r.kind === 'grab')) === null || _e === void 0 ? void 0 : _e.pointer);
    }
    // Public toggle API
    toggleSubPointer(kind, enabled) {
        var _a;
        const entry = kind === 'ray' ? this.ray : this.grab;
        if (!entry) {
            return false;
        }
        if (enabled && !entry.registered) {
            const isDefault = kind === this.defaultKind;
            const unregister = this.combined.register(entry.pointer, isDefault);
            this.registered.push({ kind, pointer: entry.pointer, unregister });
            entry.unregister = unregister;
            entry.registered = true;
            return true;
        }
        else if (!enabled && entry.registered) {
            (_a = entry.unregister) === null || _a === void 0 ? void 0 : _a.call(entry);
            entry.unregister = undefined;
            entry.registered = false;
            const idx = this.registered.findIndex((r) => r.pointer === entry.pointer);
            if (idx >= 0) {
                this.registered.splice(idx, 1);
            }
            return true;
        }
        return false;
    }
    getSubPointerState(kind) {
        const entry = kind === 'ray' ? this.ray : this.grab;
        return { registered: !!(entry === null || entry === void 0 ? void 0 : entry.registered) };
    }
    setDefault(kind) {
        this.defaultKind = kind;
        // Re-register current pointers to update default preference
        const snapshot = [...this.registered];
        // Unregister all
        snapshot.forEach((r) => r.unregister());
        this.registered.length = 0;
        // Re-register in same order with updated isDefault flags
        if (this.ray) {
            if (this.ray.registered) {
                const unregister = this.combined.register(this.ray.pointer, this.defaultKind === 'ray');
                this.registered.push({
                    kind: 'ray',
                    pointer: this.ray.pointer,
                    unregister,
                });
                this.ray.unregister = unregister;
            }
        }
        if (this.grab) {
            if (this.grab.registered) {
                const unregister = this.combined.register(this.grab.pointer, this.defaultKind === 'grab');
                this.registered.push({
                    kind: 'grab',
                    pointer: this.grab.pointer,
                    unregister,
                });
                this.grab.unregister = unregister;
            }
        }
    }
}

export { MultiPointer };
//# sourceMappingURL=multi-pointer.js.map
