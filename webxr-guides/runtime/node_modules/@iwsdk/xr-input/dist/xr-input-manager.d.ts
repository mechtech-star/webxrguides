/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { Signal } from '@preact/signals-core';
import { PerspectiveCamera, Scene, WebXRManager } from 'three';
import { GLTF, GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { StatefulGamepad } from './gamepad/stateful-gamepad.js';
import { MultiPointer } from './pointer/multi-pointer.js';
import { XROrigin } from './rig/xr-origin.js';
import { XRInputVisualAdapter } from './visual/adapter/base-visual-adapter.js';
import { XRControllerVisualAdapter } from './visual/adapter/controller-visual-adapter.js';
import { XRHandVisualAdapter } from './visual/adapter/hand-visual-adapter.js';
import { VisualConstructor, VisualImplementation } from './visual/impl/base-impl.js';
export declare enum XRInputDeviceType {
    Controller = "controller",
    Hand = "hand"
}
export interface XRAssetLoader {
    loadGLTF(assetPath: string): Promise<GLTF>;
}
export declare const DefaultXRAssetLoader: {
    gltfLoader: GLTFLoader;
    loadGLTF(assetPath: string): Promise<GLTF>;
};
export interface XRInputDeviceConfig {
    handedness: XRHandedness;
    type: XRInputDeviceType;
    enabled?: boolean;
    visualClass?: VisualConstructor<VisualImplementation>;
}
export interface XRPointerSettings {
    enabled?: boolean;
}
export interface XRInputOptions {
    camera: PerspectiveCamera;
    scene: Scene;
    assetLoader?: XRAssetLoader;
    inputDevices?: XRInputDeviceConfig[];
    pointerSettings?: XRPointerSettings;
}
export declare class XRInputManager {
    readonly xrOrigin: XROrigin;
    readonly multiPointers: Record<'left' | 'right', MultiPointer>;
    readonly gamepads: Record<"left" | "right", StatefulGamepad | undefined>;
    readonly visualAdapters: {
        controller: {
            left: XRControllerVisualAdapter;
            right: XRControllerVisualAdapter;
        };
        hand: {
            left: XRHandVisualAdapter;
            right: XRHandVisualAdapter;
        };
        left: Signal<XRInputVisualAdapter | undefined>;
        right: Signal<XRInputVisualAdapter | undefined>;
    };
    private activeInputSources;
    private primaryInputSources;
    private scene;
    private hadSession;
    private processedInputSourceKeys;
    constructor(options: XRInputOptions);
    update(xrManager: WebXRManager, delta: number, time: number): void;
    private onSessionEnded;
    isPrimary(deviceType: 'controller' | 'hand', handedness: 'left' | 'right'): boolean;
    private resetActiveInputSources;
    /**
     * Updates the active input sources from the XR session.
     *
     * IMPORTANT: This method handles a platform quirk where some runtimes
     * include the same hands in BOTH session.inputSources AND session.trackedSources.
     * The duplicate entries represent the same physical hands but as different XRInputSource objects
     * with different properties (e.g., different gamepad.buttons lengths).
     *
     * To prevent the trackedSources from overwriting the isPrimary status set by inputSources,
     * we track which handedness+type combinations have already been processed and skip
     * re-processing duplicates from trackedSources.
     *
     * Without this deduplication:
     * - Hands from inputSources would be marked as isPrimary=true
     * - Then the same hands from trackedSources would overwrite with isPrimary=false
     * - This causes hand visuals to not be displayed (since visibility is tied to isPrimary)
     */
    private updateActiveInputSources;
    private assignInputSource;
    private updateControllersAndHands;
    private updatePointers;
}
//# sourceMappingURL=xr-input-manager.d.ts.map