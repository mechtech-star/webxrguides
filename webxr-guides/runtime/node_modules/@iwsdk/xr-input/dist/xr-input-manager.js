import { signal } from '@preact/signals-core';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { loadInputProfile } from './gamepad/input-profiles.js';
import { StatefulGamepad } from './gamepad/stateful-gamepad.js';
import { MultiPointer } from './pointer/multi-pointer.js';
import { XROrigin } from './rig/xr-origin.js';
import { XRControllerVisualAdapter } from './visual/adapter/controller-visual-adapter.js';
import { XRHandVisualAdapter } from './visual/adapter/hand-visual-adapter.js';
import { AnimatedController } from './visual/impl/animated-controller.js';
import { AnimatedHand } from './visual/impl/animated-hand.js';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XRInputDeviceType;
(function (XRInputDeviceType) {
    XRInputDeviceType["Controller"] = "controller";
    XRInputDeviceType["Hand"] = "hand";
})(XRInputDeviceType || (XRInputDeviceType = {}));
const DefaultXRAssetLoader = {
    gltfLoader: new GLTFLoader(),
    async loadGLTF(assetPath) {
        return await DefaultXRAssetLoader.gltfLoader.loadAsync(assetPath);
    },
};
class XRInputManager {
    constructor(options) {
        this.gamepads = {
            left: undefined,
            right: undefined,
        };
        this.activeInputSources = {
            hand: { left: undefined, right: undefined },
            controller: { left: undefined, right: undefined },
        };
        this.primaryInputSources = {
            left: undefined,
            right: undefined,
        };
        this.hadSession = false;
        this.processedInputSourceKeys = new Set();
        const { scene, camera, assetLoader } = options;
        this.xrOrigin = new XROrigin();
        this.scene = scene; // used implicitly by MultiPointer via constructor
        this.visualAdapters = {
            controller: {
                left: new XRControllerVisualAdapter(this.xrOrigin, 'left', true, // visuals enabled
                AnimatedController, scene, camera, assetLoader || DefaultXRAssetLoader),
                right: new XRControllerVisualAdapter(this.xrOrigin, 'right', true, // visuals enabled
                AnimatedController, scene, camera, assetLoader || DefaultXRAssetLoader),
            },
            hand: {
                left: new XRHandVisualAdapter(this.xrOrigin, 'left', true, // visuals enabled
                AnimatedHand, scene, camera, assetLoader || DefaultXRAssetLoader),
                right: new XRHandVisualAdapter(this.xrOrigin, 'right', true, // visuals enabled
                AnimatedHand, scene, camera, assetLoader || DefaultXRAssetLoader),
            },
            left: signal(undefined),
            right: signal(undefined),
        };
        this.multiPointers = {
            left: new MultiPointer('left', this.scene, camera, this.xrOrigin),
            right: new MultiPointer('right', this.scene, camera, this.xrOrigin),
        };
    }
    update(xrManager, delta, time) {
        const session = xrManager.getSession();
        if (!session) {
            if (this.hadSession) {
                this.onSessionEnded();
            }
            this.hadSession = false;
            return;
        }
        this.hadSession = true;
        const refSpace = xrManager.getReferenceSpace();
        const frame = xrManager.getFrame();
        if (!refSpace || !frame) {
            return;
        }
        // Reset active input sources
        this.resetActiveInputSources();
        // Update active input sources
        this.updateActiveInputSources(session);
        // Update controllers and hands (poses + visuals + gamepads)
        this.updateControllersAndHands(frame, refSpace, delta);
        // Update head tracking
        this.xrOrigin.updateHead(frame, refSpace);
        // Force matrix update for xrOrigin, and then update pointers
        this.xrOrigin.updateMatrixWorld(true);
        this.updatePointers(delta, time);
    }
    onSessionEnded() {
        // Clear active sources and visuals
        this.resetActiveInputSources();
        // Disconnect controller/hand visuals and clear primary adapters
        ['left', 'right'].forEach((handedness) => {
            const ctrl = this.visualAdapters.controller[handedness];
            const hand = this.visualAdapters.hand[handedness];
            if (ctrl.connected) {
                ctrl.disconnect();
            }
            if (hand.connected) {
                hand.disconnect();
            }
        });
        this.visualAdapters.left.value = undefined;
        this.visualAdapters.right.value = undefined;
        // Hide pointer visuals and disable combined pointers
        try {
            this.multiPointers.left.update(false, 0, 0);
            this.multiPointers.right.update(false, 0, 0);
        }
        catch (_a) { }
    }
    isPrimary(deviceType, handedness) {
        var _a;
        return !!((_a = this.activeInputSources[deviceType][handedness]) === null || _a === void 0 ? void 0 : _a.isPrimary);
    }
    resetActiveInputSources() {
        this.activeInputSources.controller.left = undefined;
        this.activeInputSources.controller.right = undefined;
        this.activeInputSources.hand.left = undefined;
        this.activeInputSources.hand.right = undefined;
        this.primaryInputSources.left = undefined;
        this.primaryInputSources.right = undefined;
    }
    /**
     * Updates the active input sources from the XR session.
     *
     * IMPORTANT: This method handles a platform quirk where some runtimes
     * include the same hands in BOTH session.inputSources AND session.trackedSources.
     * The duplicate entries represent the same physical hands but as different XRInputSource objects
     * with different properties (e.g., different gamepad.buttons lengths).
     *
     * To prevent the trackedSources from overwriting the isPrimary status set by inputSources,
     * we track which handedness+type combinations have already been processed and skip
     * re-processing duplicates from trackedSources.
     *
     * Without this deduplication:
     * - Hands from inputSources would be marked as isPrimary=true
     * - Then the same hands from trackedSources would overwrite with isPrimary=false
     * - This causes hand visuals to not be displayed (since visibility is tied to isPrimary)
     */
    updateActiveInputSources(session) {
        this.processedInputSourceKeys.clear();
        // Process inputSources (these are primary)
        for (const inputSource of session.inputSources) {
            this.assignInputSource(inputSource, true);
            const key = `${inputSource.handedness}-${inputSource.hand ? 'hand' : 'controller'}`;
            this.processedInputSourceKeys.add(key);
        }
        // Process trackedSources (these are non-primary)
        // Skip any that were already in inputSources to avoid overwriting isPrimary
        if (session.trackedSources) {
            for (const inputSource of session.trackedSources) {
                const key = `${inputSource.handedness}-${inputSource.hand ? 'hand' : 'controller'}`;
                if (!this.processedInputSourceKeys.has(key)) {
                    this.assignInputSource(inputSource, false);
                }
            }
        }
    }
    assignInputSource(inputSource, isPrimary) {
        const handedness = inputSource.handedness;
        if (handedness === 'left' || handedness === 'right') {
            const target = inputSource.hand
                ? this.activeInputSources.hand
                : this.activeInputSources.controller;
            target[handedness] = { inputSource, isPrimary };
            if (isPrimary) {
                this.primaryInputSources[handedness] = inputSource;
            }
        }
    }
    updateControllersAndHands(frame, refSpace, delta) {
        ['left', 'right'].forEach((handedness) => {
            ['controller', 'hand'].forEach((key) => {
                const inputSourceData = this.activeInputSources[key][handedness];
                const visualAdapter = this.visualAdapters[key][handedness];
                if (inputSourceData) {
                    const { inputSource, isPrimary } = inputSourceData;
                    const raySpace = isPrimary
                        ? this.xrOrigin.raySpaces[handedness]
                        : this.xrOrigin.secondaryRaySpaces[handedness];
                    const gripSpace = isPrimary
                        ? this.xrOrigin.gripSpaces[handedness]
                        : this.xrOrigin.secondaryGripSpaces[handedness];
                    visualAdapter.raySpace = raySpace;
                    visualAdapter.gripSpace = gripSpace;
                    updatePose(frame, inputSource.targetRaySpace, refSpace, raySpace);
                    if (inputSource.gripSpace) {
                        updatePose(frame, inputSource.gripSpace, refSpace, gripSpace);
                    }
                    else {
                        gripSpace.position.copy(raySpace.position);
                        gripSpace.quaternion.copy(raySpace.quaternion);
                        gripSpace.scale.copy(raySpace.scale);
                    }
                    if (visualAdapter.inputSource !== inputSourceData.inputSource) {
                        visualAdapter.connect(inputSourceData.inputSource);
                    }
                    visualAdapter.update(frame, delta);
                    visualAdapter.isPrimary = inputSourceData.isPrimary;
                    if (visualAdapter.isPrimary) {
                        this.visualAdapters[handedness].value = visualAdapter;
                    }
                    if (visualAdapter.visual) {
                        visualAdapter.visual.model.visible = inputSourceData.isPrimary;
                    }
                }
                else if (visualAdapter.connected) {
                    visualAdapter.disconnect();
                }
            });
        });
        ['left', 'right'].forEach((handedness) => {
            var _a, _b;
            const inputSource = this.primaryInputSources[handedness];
            // If the input source changed, clear the cached StatefulGamepad.
            if (((_a = this.gamepads[handedness]) === null || _a === void 0 ? void 0 : _a.inputSource) !== inputSource) {
                this.gamepads[handedness] = undefined;
            }
            const hasGamepad = !!(inputSource && inputSource.gamepad);
            // Lazily create a StatefulGamepad only when a gamepad is available.
            if (!this.gamepads[handedness] && hasGamepad) {
                const inputConfig = loadInputProfile(inputSource);
                this.gamepads[handedness] = new StatefulGamepad(inputConfig);
            }
            // Update if present and source still has a gamepad.
            if (hasGamepad) {
                (_b = this.gamepads[handedness]) === null || _b === void 0 ? void 0 : _b.update();
            }
        });
    }
    updatePointers(delta, time) {
        ['left', 'right'].forEach((handedness) => {
            var _a, _b;
            const inputSource = this.primaryInputSources[handedness];
            const hasGamepad = !!(inputSource && inputSource.gamepad);
            const connected = !!(inputSource &&
                hasGamepad &&
                this.gamepads[handedness]);
            const selectStart = connected
                ? !!((_a = this.gamepads[handedness]) === null || _a === void 0 ? void 0 : _a.getSelectStart())
                : false;
            const selectEnd = connected
                ? !!((_b = this.gamepads[handedness]) === null || _b === void 0 ? void 0 : _b.getSelectEnd())
                : false;
            // First: move all registered pointers (ray + grab) via the combined pointer
            const gp = this.gamepads[handedness];
            const squeezeStart = connected
                ? !!(gp === null || gp === void 0 ? void 0 : gp.getButtonDown('xr-standard-squeeze'))
                : false;
            const squeezeEnd = connected
                ? !!(gp === null || gp === void 0 ? void 0 : gp.getButtonUp('xr-standard-squeeze'))
                : false;
            this.multiPointers[handedness].update(connected, delta, time, {
                selectStart,
                selectEnd,
                squeezeStart,
                squeezeEnd,
            });
        });
    }
}
function updatePose(frame, xrSpace, refSpace, group) {
    const xrPose = frame.getPose(xrSpace, refSpace);
    if (xrPose) {
        group.matrix.fromArray(xrPose.transform.matrix);
        group.matrix.decompose(group.position, group.quaternion, group.scale);
    }
}

export { DefaultXRAssetLoader, XRInputDeviceType, XRInputManager };
//# sourceMappingURL=xr-input-manager.js.map
