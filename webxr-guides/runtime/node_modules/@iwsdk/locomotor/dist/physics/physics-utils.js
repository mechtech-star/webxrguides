/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Static physics utility functions for locomotion
 * Performance-optimized with no object allocations
 */
class PhysicsUtils {
    static calculateSpringForce(displacement, springConstant) {
        return springConstant * displacement;
    }
    static calculateDampingForce(velocity, dampingConstant) {
        return dampingConstant * velocity;
    }
    static clampForce(force, maxForce) {
        return Math.max(-maxForce, Math.min(maxForce, force));
    }
    static applyGravity(velocity, gravityDir, gravity, gravityMultiplier, delta) {
        velocity.addScaledVector(gravityDir, gravity * gravityMultiplier * delta);
    }
    static applyFloatingForce(velocity, upAxis, springForce, dampingForce, maxForce, mass, delta) {
        const floatForce = springForce - dampingForce;
        const cappedFloatForce = PhysicsUtils.clampForce(floatForce, maxForce);
        const acceleration = (cappedFloatForce * delta) / mass;
        velocity.addScaledVector(upAxis, acceleration);
    }
    static calculateTargetDistance(floatHeight, capsuleRadius) {
        return floatHeight + capsuleRadius;
    }
    static isGrounded(groundDistance, groundingThreshold) {
        return groundDistance < groundingThreshold;
    }
    static calculateGroundingThreshold(floatHeight, capsuleRadius, buffer = 0.15) {
        return floatHeight + capsuleRadius + buffer;
    }
    static isWalkableSlope(surfaceNormal, upAxis, maxSlope) {
        const slopeAngle = surfaceNormal.angleTo(upAxis);
        return slopeAngle < maxSlope;
    }
    static capVelocity(velocity, maxVelocity) {
        if (velocity.lengthSq() > maxVelocity * maxVelocity) {
            velocity.normalize().multiplyScalar(maxVelocity);
        }
    }
}

export { PhysicsUtils };
//# sourceMappingURL=physics-utils.js.map
