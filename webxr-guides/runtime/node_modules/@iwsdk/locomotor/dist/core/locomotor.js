import { Vector3, Quaternion, Matrix4, Object3D } from 'three';
import { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { EnvironmentType } from '../types/environment-types.js';
import { MessageType } from '../types/message-types.js';
import { LocomotionEngine } from './engine.js';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const UNIT_SCALE = new Vector3(1, 1, 1);
/**
 * Main thread interface for locomotion physics engine
 * Supports both web worker mode (default) and inline mode
 *
 * - Worker mode: Runs physics engine in a separate thread for better performance
 * - Inline mode: Runs physics engine in the same thread for snappier controls
 *
 * Use LocomotorConfig.useWorker to control the mode (default: true)
 */
class Locomotor {
    constructor(config = {}) {
        this.hitTestNormal = new Vector3();
        this.isGrounded = false;
        this.position = new Vector3();
        this.initialized = false;
        // Environment handle tracking - split by type for easier usage
        this.staticEnvs = new Map();
        this.kinematicEnvs = new Map();
        this.nextEnvironmentHandle = 1;
        this.targetPosition = new Vector3();
        this.tempVec1 = new Vector3();
        this.tempVec2 = new Vector3();
        this.tempQuat = new Quaternion();
        this.tempMatrix = new Matrix4();
        this.tempMatrix2 = new Matrix4();
        this.requestArr = new Array(7);
        this.kinematicUpdateArr = new Array(18);
        this.config = {
            initialPlayerPosition: new Vector3(0, 2, 0),
            updateFrequency: 60,
            rayGravity: -0.4,
            maxDropDistance: 5.0,
            jumpHeight: 1.5,
            jumpCooldown: 0.1,
            useWorker: true,
            ...config,
        };
        this.useWorker = this.config.useWorker;
        this.hitTestTarget = new Object3D();
        this.hitTestTarget.visible = false;
    }
    async initialize() {
        if (this.initialized) {
            return;
        }
        if (this.useWorker) {
            // Create worker using lazy loading pattern (await will be handled by plugin)
            this.worker = new Worker((await import('../worker/worker.js')).url);
            this.worker.postMessage({
                type: MessageType.Init,
                payload: {
                    initialPlayerPosition: this.config.initialPlayerPosition.toArray(),
                },
            });
            this.worker.onmessage = (e) => {
                this.handleWorkerMessage(e);
            };
            this.updateConfig(this.config);
        }
        else {
            this.engine = new LocomotionEngine(this.config.initialPlayerPosition);
            this.applyConfigToEngine(this.config);
            this.position.copy(this.engine.playerPosition);
            this.isGrounded = this.engine.isGrounded;
        }
        this.initialized = true;
    }
    terminate() {
        if (this.useWorker && this.worker) {
            this.worker.terminate();
            this.worker = undefined;
        }
        else if (!this.useWorker) {
            this.engine = undefined;
        }
        this.initialized = false;
        this.staticEnvs.clear();
        this.kinematicEnvs.clear();
    }
    updateConfig(config) {
        Object.assign(this.config, config);
        if (this.useWorker && this.worker) {
            this.worker.postMessage({
                type: MessageType.Config,
                payload: {
                    updateFrequency: this.config.updateFrequency,
                    rayGravity: this.config.rayGravity,
                    maxDropDistance: this.config.maxDropDistance,
                    jumpHeight: this.config.jumpHeight,
                    jumpCooldown: this.config.jumpCooldown,
                },
            });
        }
        else if (!this.useWorker && this.engine) {
            this.applyConfigToEngine(this.config);
        }
    }
    applyConfigToEngine(config) {
        if (!this.engine) {
            return;
        }
        if (config.rayGravity !== undefined) {
            this.engine.rayGravity = config.rayGravity;
        }
        if (config.maxDropDistance !== undefined) {
            this.engine.setMaxDropDistance(config.maxDropDistance);
        }
        if (config.jumpHeight !== undefined) {
            this.engine.jumpHeight = config.jumpHeight;
        }
        if (config.jumpCooldown !== undefined) {
            this.engine.jumpCooldown = config.jumpCooldown;
        }
    }
    /**
     * Update method for inline mode (when useWorker is false)
     * This method must be called every frame when using inline mode.
     * In worker mode, this method does nothing as updates are handled automatically.
     *
     * @param delta Time in seconds since last update
     */
    update(delta) {
        if (!this.initialized) {
            return;
        }
        if (this.useWorker && this.worker) {
            this.position.lerp(this.targetPosition, delta * 10);
        }
        else if (!this.useWorker && this.engine) {
            this.engine.update(delta);
            this.position.copy(this.engine.playerPosition);
            this.isGrounded = this.engine.isGrounded;
        }
    }
    addEnvironment(object3D, type = EnvironmentType.STATIC) {
        if (!this.initialized || !(object3D === null || object3D === void 0 ? void 0 : object3D.isObject3D)) {
            throw new Error('Locomotor not initialized or invalid Object3D');
        }
        const envHandle = this.nextEnvironmentHandle++;
        const { positions, indices, worldMatrix } = this.processEnvironment(object3D);
        if (type === EnvironmentType.KINEMATIC) {
            this.kinematicEnvs.set(envHandle, object3D);
        }
        else {
            this.staticEnvs.set(envHandle, object3D);
        }
        if (this.useWorker && this.worker) {
            this.worker.postMessage({
                type: MessageType.AddEnvironment,
                payload: {
                    handle: envHandle,
                    positions,
                    indices,
                    type,
                    worldMatrix: worldMatrix.elements,
                },
            });
        }
        else if (!this.useWorker && this.engine) {
            this.engine.addEnvironment(envHandle, positions, indices, type, worldMatrix);
        }
        return envHandle;
    }
    removeEnvironment(envHandle) {
        if (!this.initialized) {
            return;
        }
        const isKinematic = this.kinematicEnvs.has(envHandle);
        const isStatic = this.staticEnvs.has(envHandle);
        if (!isKinematic && !isStatic) {
            return;
        }
        if (isKinematic) {
            this.kinematicEnvs.delete(envHandle);
        }
        else {
            this.staticEnvs.delete(envHandle);
        }
        if (this.useWorker && this.worker) {
            this.worker.postMessage({
                type: MessageType.RemoveEnvironment,
                payload: { handle: envHandle },
            });
        }
        else if (!this.useWorker && this.engine) {
            this.engine.removeEnvironment(envHandle);
        }
    }
    updateKinematicEnvironments(envHandles) {
        if (!this.initialized) {
            return;
        }
        const handlesToUpdate = envHandles || Array.from(this.kinematicEnvs.keys());
        for (const envHandle of handlesToUpdate) {
            const object3D = this.kinematicEnvs.get(envHandle);
            if (!(object3D === null || object3D === void 0 ? void 0 : object3D.isObject3D)) {
                continue;
            }
            object3D.updateMatrixWorld(true);
            this.tempMatrix.copy(object3D.matrixWorld);
            this.tempMatrix.decompose(this.tempVec1, this.tempQuat, this.tempVec2);
            this.tempMatrix.compose(this.tempVec1, this.tempQuat, UNIT_SCALE);
            if (this.useWorker && this.worker) {
                this.kinematicUpdateArr[0] = MessageType.UpdateKinematicEnvironment;
                this.kinematicUpdateArr[1] = envHandle;
                for (let i = 0; i < 16; i++) {
                    this.kinematicUpdateArr[i + 2] = this.tempMatrix.elements[i];
                }
                this.worker.postMessage(this.kinematicUpdateArr);
            }
            else if (!this.useWorker && this.engine) {
                this.engine.updateKinematicPlatform(envHandle, this.tempMatrix);
            }
        }
    }
    slide(direction) {
        if (!this.initialized) {
            return;
        }
        if (this.useWorker && this.worker) {
            this.requestArr[0] = MessageType.Slide;
            direction.toArray(this.requestArr, 1);
            this.worker.postMessage(this.requestArr);
        }
        else if (!this.useWorker && this.engine) {
            this.engine.slide(direction);
        }
    }
    teleport(position) {
        if (!this.initialized) {
            return;
        }
        if (this.useWorker && this.worker) {
            this.requestArr[0] = MessageType.Teleport;
            position.toArray(this.requestArr, 1);
            this.worker.postMessage(this.requestArr);
        }
        else if (!this.useWorker && this.engine) {
            this.engine.teleport(position);
        }
    }
    requestHitTest(origin, direction) {
        if (!this.initialized) {
            return;
        }
        if (this.useWorker && this.worker) {
            this.requestArr[0] = MessageType.ParabolicRaycast;
            origin.toArray(this.requestArr, 1);
            direction.toArray(this.requestArr, 4);
            this.worker.postMessage(this.requestArr);
        }
        else if (!this.useWorker && this.engine) {
            const intersect = this.engine.parabolicRaycast(origin, direction);
            const data = new Array(7).fill(NaN);
            data[0] = MessageType.RaycastUpdate;
            if (intersect) {
                intersect.point.toArray(data, 1);
                if (intersect.face) {
                    intersect.face.normal.toArray(data, 4);
                }
            }
            this.handleHitTestResult(data);
        }
    }
    jump() {
        if (!this.initialized) {
            return;
        }
        if (this.useWorker && this.worker) {
            this.worker.postMessage([MessageType.Jump]);
        }
        else if (!this.useWorker && this.engine) {
            this.engine.jump();
        }
    }
    isInitialized() {
        return this.initialized;
    }
    processEnvironment(object3D) {
        object3D.updateMatrixWorld(true);
        this.tempMatrix.copy(object3D.matrixWorld);
        this.tempMatrix.decompose(this.tempVec1, this.tempQuat, this.tempVec2);
        this.tempMatrix.compose(this.tempVec1, this.tempQuat, UNIT_SCALE);
        const geometries = [];
        object3D.traverse((child) => {
            if (child.isMesh && child.geometry) {
                const geometry = child.geometry.clone();
                geometry.applyMatrix4(child.matrixWorld);
                geometries.push(geometry);
            }
        });
        const mergedGeometry = mergeGeometries(geometries);
        this.tempMatrix2.copy(this.tempMatrix).invert();
        mergedGeometry.applyMatrix4(this.tempMatrix2);
        object3D.matrixWorld.copy(this.tempMatrix);
        return {
            positions: mergedGeometry.attributes.position.array,
            indices: mergedGeometry.index.array,
            worldMatrix: this.tempMatrix.clone(),
        };
    }
    handleWorkerMessage(e) {
        if (e.data instanceof Array) {
            const messageType = e.data[0];
            if (messageType === MessageType.PositionUpdate) {
                this.targetPosition.fromArray(e.data, 1);
                this.isGrounded = e.data[5] === 1;
            }
            else if (messageType === MessageType.RaycastUpdate) {
                this.handleHitTestResult(e.data);
            }
        }
    }
    handleHitTestResult(data) {
        const hit = !isNaN(data[1]) && !isNaN(data[2]) && !isNaN(data[3]);
        if (hit) {
            this.tempVec1.fromArray(data, 1);
            this.tempVec2.fromArray(data, 4);
            this.hitTestTarget.position.copy(this.tempVec1);
            this.hitTestTarget.lookAt(this.tempVec1.add(this.tempVec2));
            this.hitTestNormal.copy(this.tempVec2);
            this.hitTestTarget.visible = true;
        }
        else {
            this.hitTestTarget.visible = false;
        }
    }
}

export { EnvironmentType, Locomotor };
//# sourceMappingURL=locomotor.js.map
