import { Vector3, Ray, Line3, Matrix4 } from 'three';
import { EnvironmentManager } from '../environment/environment-manager.js';
import { CollisionHandler } from '../physics/collision-handler.js';
import { GroundDetector } from '../physics/ground-detector.js';
import { sampleParabolicCurve } from '../physics/math-utils.js';
import { PhysicsUtils } from '../physics/physics-utils.js';
import { EnvironmentType } from '../types/environment-types.js';
import { MovementController } from './movement-controller.js';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class LocomotionEngine {
    constructor(initPosition) {
        this.playerPosition = new Vector3();
        this.playerVelocity = new Vector3();
        this.movementVector = new Vector3();
        this.ray = new Ray();
        this.capsuleInfo = {
            radius: 0.5,
            segment: new Line3(new Vector3(0, 1.5, 0), new Vector3(0, 0.5, 0)),
        };
        this.lastUpdateTime = 0;
        this.rayPoints = new Array();
        this.rayVector = new Vector3();
        this.upAxis = new Vector3(0, 1, 0);
        this.gravityDir = new Vector3(0, -1, 0);
        this.groundDecel = 8;
        this.positionUpdateTimeout = 0.5;
        this.gravity = 9.81;
        this.rayGravity = -0.4;
        this.updating = false;
        this.isGrounded = false;
        this.isGroundedOnStatic = false;
        this.maxDropDistance = 2.0;
        this.jumpHeight = 1.5;
        this.jumpCooldown = 0.1;
        this.lastJumpTime = 0;
        this.acceleration = 100;
        this.deceleration = 100;
        this.airDragFactor = 0.3;
        this.maxWalkSpeed = 3;
        this.mass = 1;
        this.floatHeight = 0.01;
        this.floatSensorRadius = 0.12;
        this.floatSpringK = 30;
        this.floatDampingC = 8;
        this.maxSlope = 1;
        this.playerPosition.copy(initPosition);
        for (let i = 0; i < 10; i++) {
            this.rayPoints.push(new Vector3());
        }
        this.environmentManager = new EnvironmentManager();
        this.groundDetector = new GroundDetector(this.gravityDir, this.upAxis, this.environmentManager);
        this.collisionHandler = new CollisionHandler();
        this.movementController = new MovementController({
            acceleration: this.acceleration,
            deceleration: this.deceleration,
            airDragFactor: this.airDragFactor,
            maxWalkSpeed: this.maxWalkSpeed,
        });
        // Set initial maxDropDistance on environment manager
        this.environmentManager.setMaxDropDistance(this.maxDropDistance);
    }
    slide(movementVector) {
        this.movementVector.copy(movementVector);
        this.updating = true;
        this.lastUpdateTime = performance.now();
    }
    teleport(position) {
        this.playerPosition.copy(position);
        this.playerVelocity.set(0, 0, 0);
        this.updating = true;
        this.lastUpdateTime = performance.now();
    }
    raycast(origin, direction, far) {
        this.ray.origin.copy(origin);
        this.ray.direction.copy(direction);
        let closestIntersect;
        for (const env of this.environmentManager.getEnvironments()) {
            const intersect = this.environmentManager.raycastEnvironment(env, this.ray, 0, far);
            if (intersect &&
                (!closestIntersect || intersect.distance < closestIntersect.distance)) {
                closestIntersect = intersect;
            }
        }
        return closestIntersect;
    }
    raycastRelevantEnvironments(origin, direction, far, environments) {
        this.ray.origin.copy(origin);
        this.ray.direction.copy(direction);
        let closestIntersect;
        for (const env of environments) {
            const intersect = this.environmentManager.raycastEnvironment(env, this.ray, 0, far);
            if (intersect &&
                (!closestIntersect || intersect.distance < closestIntersect.distance)) {
                closestIntersect = intersect;
            }
        }
        return closestIntersect;
    }
    parabolicRaycast(origin, direction) {
        let intersect;
        const minY = this.environmentManager.getMinY(this.playerPosition.y);
        // Get environments that potentially intersect with trajectory (broad-phase)
        const relevantEnvs = this.environmentManager.getEnvironmentsForTrajectory(origin, direction, minY, this.rayGravity);
        sampleParabolicCurve(origin, direction, minY, this.rayGravity, this.rayPoints);
        for (let i = 0; i < this.rayPoints.length - 1; i++) {
            this.rayVector.copy(this.rayPoints[i + 1]).sub(this.rayPoints[i]);
            const far = this.rayVector.length();
            intersect = this.raycastRelevantEnvironments(this.rayPoints[i], this.rayVector.normalize(), far, relevantEnvs);
            if (intersect) {
                break;
            }
        }
        return intersect;
    }
    update(delta) {
        this.environmentManager.updateKinematicPlatforms(delta);
        if (!this.updating) {
            return;
        }
        // Kinematic platforms require continuous updates since they can move at any time
        // Only allow sleep when grounded on static environments
        if (this.isGroundedOnStatic &&
            performance.now() - this.lastUpdateTime >
                this.positionUpdateTimeout * 1000) {
            this.updating = false;
        }
        else {
            this.updatePlayerPosition(delta);
        }
    }
    updatePlayerPosition(delta) {
        this.handleMovementPhysics(delta);
        this.applyGravity(delta);
        this.handleGroundContact(delta);
        this.handleCollisions();
        if (this.playerPosition.y > 100) {
            this.playerPosition.set(0, 2, 0);
            this.playerVelocity.set(0, 0, 0);
            return;
        }
        PhysicsUtils.capVelocity(this.playerVelocity, 20);
        this.playerPosition.addScaledVector(this.playerVelocity, delta);
    }
    handleMovementPhysics(delta) {
        this.movementController.handleMovementInput(this.movementVector, this.playerVelocity, this.isGrounded, delta);
    }
    applyGravity(delta) {
        if (!this.isGrounded) {
            const gravityMultiplier = this.playerPosition.y > 10 ? 3 : 1;
            PhysicsUtils.applyGravity(this.playerVelocity, this.gravityDir, this.gravity, gravityMultiplier, delta);
        }
    }
    handleGroundContact(delta) {
        var _a, _b;
        const groundInfo = this.groundDetector.detectGround(this.environmentManager.getEnvironments(), this.playerPosition, this.capsuleInfo.radius, this.floatHeight, this.maxSlope);
        this.isGrounded = groundInfo.isGrounded;
        this.isGroundedOnStatic =
            this.isGrounded &&
                ((_a = groundInfo.environment) === null || _a === void 0 ? void 0 : _a.type) === EnvironmentType.STATIC;
        if (this.isGrounded &&
            ((_b = groundInfo.environment) === null || _b === void 0 ? void 0 : _b.type) === EnvironmentType.KINEMATIC) {
            this.groundDetector.applyPlatformVelocity(this.playerVelocity, groundInfo);
        }
        if (groundInfo.distance < Infinity && this.isGrounded) {
            const targetDistance = PhysicsUtils.calculateTargetDistance(this.floatHeight, this.capsuleInfo.radius);
            const springDisplacement = targetDistance - groundInfo.distance;
            const springForce = PhysicsUtils.calculateSpringForce(springDisplacement, this.floatSpringK);
            const verticalVelocity = this.playerVelocity.dot(this.upAxis);
            const dampingForce = PhysicsUtils.calculateDampingForce(verticalVelocity, this.floatDampingC);
            PhysicsUtils.applyFloatingForce(this.playerVelocity, this.upAxis, springForce, dampingForce, 50, this.mass, delta);
        }
    }
    handleCollisions() {
        const correctedPosition = this.collisionHandler.handleCapsuleCollision(this.environmentManager.getEnvironments(), this.capsuleInfo, this.playerPosition, this.playerVelocity);
        if (!correctedPosition.equals(this.playerPosition)) {
            this.playerPosition.copy(correctedPosition);
        }
    }
    addEnvironment(handle, positions, indices, type = EnvironmentType.STATIC, worldMatrix = new Matrix4()) {
        this.environmentManager.addEnvironment(handle, positions, indices, type, worldMatrix);
    }
    removeEnvironment(handle) {
        this.environmentManager.removeEnvironment(handle);
    }
    updateKinematicPlatform(handle, newWorldMatrix) {
        this.environmentManager.updateKinematicPlatform(handle, newWorldMatrix);
    }
    setMaxDropDistance(distance) {
        this.maxDropDistance = distance;
        this.environmentManager.setMaxDropDistance(distance);
    }
    jump() {
        const currentTime = performance.now() / 1000;
        // Validate jump conditions
        if (!(this.isGrounded && currentTime - this.lastJumpTime > this.jumpCooldown)) {
            return;
        }
        // Calculate jump velocity using physics: v = âˆš(2gh)
        const jumpVelocity = Math.sqrt(2 * this.gravity * this.jumpHeight);
        // Set upward velocity (preserve horizontal movement)
        this.playerVelocity.y = jumpVelocity;
        // Update state
        this.isGrounded = false; // Prevent ground snapping during jump
        this.lastJumpTime = currentTime;
        this.updating = true;
    }
    getEnvironmentManager() {
        return this.environmentManager;
    }
}

export { LocomotionEngine };
//# sourceMappingURL=engine.js.map
