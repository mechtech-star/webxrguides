/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { Box3, Intersection, Matrix4, Quaternion, Ray, Vector3 } from 'three';
import { MeshBVH } from 'three-mesh-bvh';
export interface Environment {
    handle: number;
    bvh: MeshBVH;
    type: string;
    worldMatrix: Matrix4;
    worldBounds: Box3;
    metadata?: {
        deltaPos?: Vector3;
        deltaQuat?: Quaternion;
        velocity?: Vector3;
        angularVelocity?: Vector3;
        lastPosition?: Vector3;
        lastQuaternion?: Quaternion;
        position?: Vector3;
        quaternion?: Quaternion;
    };
}
/**
 * Manages multiple discrete environments and dynamic platforms
 * Manages collision environments with proper typing and lifecycle management
 */
export declare class EnvironmentManager {
    private environments;
    private staticEnvironments;
    private kinematicEnvironments;
    private maxDropDistance;
    private tempRay;
    private tempVector3_1;
    private tempVector3_2;
    private tempQuaternion_1;
    private tempQuaternion_2;
    private tempMatrix4_1;
    private tempMatrix4_2;
    private tempBox;
    /**
     * Add a new environment to the manager
     */
    addEnvironment(handle: number, positions: Float32Array | number[], indices: Uint32Array | Uint16Array | number[], type?: string, worldMatrix?: Matrix4): void;
    /**
     * Remove an environment from the manager
     */
    removeEnvironment(handle: number): void;
    /**
     * Get all environments
     */
    getEnvironments(): Environment[];
    /**
     * Get only static environments
     */
    getStaticEnvironments(): Environment[];
    /**
     * Get only kinematic (dynamic) environments
     */
    getKinematicEnvironments(): Environment[];
    /**
     * Update kinematic platform position and calculate deltas
     */
    updateKinematicPlatform(handle: number, newWorldMatrix: Matrix4): void;
    /**
     * Update kinematic platforms based on stored transforms
     * Call this each frame to track platform movement
     */
    updateKinematicPlatforms(delta: number): void;
    /**
     * Get environment by ID
     */
    getEnvironment(handle: number): Environment | undefined;
    /**
     * Check if environment exists
     */
    hasEnvironment(handle: number): boolean;
    /**
     * Utility method to perform raycast against environment with matrix transforms
     * Handles transform to local space, BVH raycast, and transform results back to world space
     */
    raycastEnvironment(env: Environment, ray: Ray, near?: number, far?: number): Intersection | null;
    /**
     * Clear all environments
     */
    clear(): void;
    private updateEnvironmentArrays;
    /**
     * Set the maximum drop distance for player-relative bounds
     */
    setMaxDropDistance(distance: number): void;
    /**
     * Get the minimum Y for parabolic raycasts based on player position
     * Uses player-relative bounds instead of absolute scene bounds
     */
    getMinY(playerY: number): number;
    /**
     * Get environments that potentially intersect with a parabolic trajectory
     * Uses broad-phase bounding box culling for performance
     */
    getEnvironmentsForTrajectory(origin: Vector3, direction: Vector3, minY: number, gravity: number): Environment[];
}
//# sourceMappingURL=environment-manager.d.ts.map