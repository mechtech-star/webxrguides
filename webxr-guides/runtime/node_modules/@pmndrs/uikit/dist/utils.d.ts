import { effect, ReadonlySignal, Signal } from '@preact/signals-core';
import { Object3D, Vector2Tuple, Color, Vector3Tuple, Vector3, Matrix4, Vector4Tuple } from 'three';
import { Inset } from './flex/node.js';
import { Properties } from './properties/index.js';
import { EventHandlersProperties } from './events.js';
import { AllowedPointerEventsType } from './panel/interaction-panel-mesh.js';
import { Component } from './components/component.js';
import { Container } from './components/container.js';
import { RootContext } from './context.js';
export type Fix_TS_56_Float32Array = Float32Array;
export declare function searchFor<T>(from: Component | Object3D, _class: {
    new (...args: Array<any>): T;
}, maxSteps: number, allowNonUikit?: boolean): T | undefined;
export declare function computedGlobalMatrix(parentMatrix: Signal<Matrix4 | undefined>, localMatrix: Signal<Matrix4 | undefined>): Signal<Matrix4 | undefined>;
export type VisibilityProperties = {
    visibility?: 'visible' | 'hidden';
};
export declare function computedIsVisible(component: Component, isClipped: Signal<boolean> | undefined, properties: Properties): ReadonlySignal<boolean>;
export declare function loadResourceWithParams<P, R, A extends Array<unknown>>(target: Signal<R | undefined>, fn: (param: P, ...additional: A) => Promise<R>, cleanup: ((value: R) => void) | undefined, abortSignal: AbortSignal, param: Signal<P> | P, ...additionals: A): void;
export declare function computedHandlers(properties: Properties, starProperties: Properties, hoveredSignal: Signal<Array<number>>, activeSignal: Signal<Array<number>>, dynamicHandlers?: Signal<EventHandlersProperties | undefined>): ReadonlySignal<EventHandlersProperties>;
export declare function computedAncestorsHaveListeners(parent: Signal<Container | undefined>, handlers: ReadonlySignal<EventHandlersProperties>): ReadonlySignal<boolean>;
export declare function addHandlers(target: EventHandlersProperties, handlers: EventHandlersProperties | undefined): void;
export declare function addHandler<T extends {
    [Key in string]?: (e: any) => void;
}, K extends keyof T>(key: K, target: T, handler: T[K]): void;
export declare function setupMatrixWorldUpdate(component: Component, rootSignal: Signal<RootContext>, globalPanelMatrixSignal: Signal<Matrix4 | undefined> | undefined, abortSignal: AbortSignal): void;
export type OutgoingDefaultProperties = {
    renderOrder: ReadonlySignal<number>;
    depthTest: ReadonlySignal<boolean>;
    depthWrite: ReadonlySignal<boolean>;
    pointerEvents: ReadonlySignal<'none' | 'auto' | 'listener'>;
    pointerEventsType: ReadonlySignal<AllowedPointerEventsType>;
    pointerEventsOrder: ReadonlySignal<number>;
};
export declare function setupPointerEvents(component: Component, canHaveNonUikitChildren: boolean): void;
export type ColorRepresentation = Color | string | number | Vector3Tuple | Vector4Tuple;
export declare function abortableEffect(fn: Parameters<typeof effect>[0], abortSignal: AbortSignal): void;
export declare const alignmentXMap: {
    left: number;
    center: number;
    middle: number;
    right: number;
};
export declare const alignmentYMap: {
    top: number;
    center: number;
    middle: number;
    bottom: number;
};
export declare const alignmentZMap: {
    back: number;
    center: number;
    middle: number;
    front: number;
};
/**
 * calculates the offsetX, offsetY, and scale to fit content with size [aspectRatio, 1] inside
 */
export declare function fitNormalizedContentInside(offsetTarget: Vector3, scaleTarget: Vector3, size: Signal<Vector2Tuple | undefined>, paddingInset: Signal<Inset | undefined>, borderInset: Signal<Inset | undefined>, pixelSize: number, aspectRatio: number): void;
export declare function readReactive<T>(value: T | 'initial' | ReadonlySignal<T | 'initial'>): T;
export declare function computedBorderInset(properties: Properties, keys: ReadonlyArray<string>): Signal<Inset>;
export declare function withOpacity(value: ReadonlySignal<ColorRepresentation> | ColorRepresentation, opacity: number | Signal<number>): ReadonlySignal<ColorRepresentation>;
type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;
type IntersectValues<T extends Record<PropertyKey, unknown>> = UnionToIntersection<T[keyof T]>;
type RecursivePartial<T> = T extends Signal<unknown> ? T : {
    [K in keyof T]?: RecursivePartial<T[K]>;
};
export type UnionizeVariants<T extends Record<PropertyKey, unknown>> = Record<keyof T, RecursivePartial<IntersectValues<T>>>;
/**
 * assumes component.root.component.parent.matrixWorld and component.root.component.matrix is updated
 */
export declare function computeWorldToGlobalMatrix(root: Pick<RootContext, 'component'>, target: Matrix4): void;
export {};
